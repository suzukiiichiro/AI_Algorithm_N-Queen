#!/usr/bin/env luajit

--[[
/**
 * Luaで学ぶアルゴリズムとデータ構造  
 * ステップバイステップでＮ−クイーン問題を最適化
 * 一般社団法人  共同通信社  情報技術局  鈴木  維一郎(suzuki.iichiro@kyodonews.jp)
 * 
 * Java版 N-Queen
 * https://github.com/suzukiiichiro/AI_Algorithm_N-Queen
 * Bash版 N-Queen
 * https://github.com/suzukiiichiro/AI_Algorithm_Bash
 * Lua版  N-Queen
 * https://github.com/suzukiiichiro/AI_Algorithm_Lua
 * 
 * https://ja.wikipedia.org/wiki/エイト・クイーン
 *
 * N-Queens問題とは
 *    Nクイーン問題とは、「8列×8行のチェスボードに8個のクイーンを、互いに効きが
 *    当たらないように並べよ」という８クイーン問題のクイーン(N)を、どこまで大き
 *    なNまで解を求めることができるかという問題。
 *    クイーンとは、チェスで使われているクイーンを指し、チェス盤の中で、縦、横、
 *    斜めにどこまでも進むことができる駒で、日本の将棋でいう「飛車と角」を合わ
 *    せた動きとなる。８列×８行で構成される一般的なチェスボードにおける8-Queens
 *    問題の解は、解の総数は92個である。比較的単純な問題なので、学部レベルの演
 *    習問題として取り上げられることが多い。
 *    8-Queens問題程度であれば、人力またはプログラムによる「力まかせ探索」でも
 *    解を求めることができるが、Nが大きくなると解が一気に爆発し、実用的な時間で
 *    は解けなくなる。
 *    現在すべての解が判明しているものは、2004年に電気通信大学で264CPU×20日をか
 *    けてn=24を解決し世界一に、その後2005 年にニッツァ大学でn=25、2016年にドレ
 *    スデン工科大学でn=27の解を求めることに成功している。
 *
 * 目次
 *  Nクイーン問題
 *  １．ブルートフォース（力まかせ探索） NQueen1() 
 *  ２．バックトラック                   NQueen2()
 *  ３．配置フラグ（制約テスト高速化）   NQueen3()
 *  ４．対称解除法(回転と斜軸）          NQueen4()
 *  ５．枝刈りと最適化                   NQueen5()
 *  ６．スレッド                         NQueen6()
 *<>７．ビットマップ                     NQueen7()
 *  ８．マルチスレッド                   NQueen8()
*/

/**
 * ７．ビットマップ
 *
 *   ビット演算を使って高速化 状態をビットマップにパックし、処理する
 *   単純なバックトラックよりも２０〜３０倍高速
 * 
 * 　ビットマップであれば、シフトにより高速にデータを移動できる。
 *  フラグ配列ではデータの移動にO(N)の時間がかかるが、ビットマップであればO(1)
 *  フラグ配列のように、斜め方向に 2*N-1の要素を用意するのではなく、Nビットで充
 *  分。
 *
 * 　配置可能なビット列を flags に入れ、-flags & flags で順にビットを取り出し処理。
 * 　バックトラックよりも２０−３０倍高速。
 * 
 * ===================
 * 考え方 1
 * ===================
 *
 * 　Ｎ×ＮのチェスボードをＮ個のビットフィールドで表し、ひとつの横列の状態をひと
 * つのビットフィールドに対応させます。(クイーンが置いてある位置のビットをONに
 * する)
 * 　そしてバックトラッキングは0番目のビットフィールドから「下に向かって」順にい
 * ずれかのビット位置をひとつだけONにして進めていきます。
 *
 * 
 *- - - - - Q - -    00000100 0番目のビットフィールド
 *- - - Q - - - -    00010000 1番目のビットフィールド
 *- - - - - - Q -    00000010 2番目のビットフィールド
 *Q - - - - - - -    10000000 3番目のビットフィールド
 *- - - - - - - Q    00000001 4番目のビットフィールド
 *- Q - - - - - -    01000000 5番目のビットフィールド
 *- - - - Q - - -    00001000 6番目のビットフィールド
 *- - Q - - - - -    00100000 7番目のビットフィールド
 *
 *
 * ===================
 * 考え方 2
 * ===================
 *
 * 次に、効き筋をチェックするためにさらに３つのビットフィールドを用意します。
 *
 * 1. 左下に効き筋が進むもの: left 
 * 2. 真下に効き筋が進むもの: down
 * 3. 右下に効き筋が進むもの: right
 *
 *次に、斜めの利き筋を考えます。
 * 上図の場合、
 * 1列目の右斜め上の利き筋は 3 番目 (0x08)
 * 2列目の右斜め上の利き筋は 2 番目 (0x04) になります。
 * この値は 0 列目のクイーンの位置 0x10 を 1 ビットずつ「右シフト」すれば求める
 * ことができます。
 * また、左斜め上の利き筋の場合、1 列目では 5 番目 (0x20) で 2 列目では 6 番目 (0x40)
 *になるので、今度は 1 ビットずつ「左シフト」すれば求めることができます。
 *
 *つまり、右シフトの利き筋を right、左シフトの利き筋を left で表すことで、クイー
 *ンの効き筋はrightとleftを1 ビットシフトするだけで求めることができるわけです。
 *
 *  *-------------
 *  | . . . . . .
 *  | . . . -3. .  0x02 -|
 *  | . . -2. . .  0x04  |(1 bit 右シフト right)
 *  | . -1. . . .  0x08 -|
 *  | Q . . . . .  0x10 ←(Q の位置は 4   down)
 *  | . +1. . . .  0x20 -| 
 *  | . . +2. . .  0x40  |(1 bit 左シフト left)  
 *  | . . . +3. .  0x80 -|
 *  *-------------
 *  図：斜めの利き筋のチェック
 *
 * n番目のビットフィールドからn+1番目のビットフィールドに探索を進めるときに、そ
 * の３つのビットフィールドとn番目のビットフィールド(bit)とのOR演算をそれぞれ行
 * います。leftは左にひとつシフトし、downはそのまま、rightは右にひとつシフトして
 * n+1番目のビットフィールド探索に渡してやります。
 *
 * left : (left |bit)<<1
 * right: (right|bit)>>1
 * down :   down|bit
 *
 *
 * ===================
 * 考え方 3
 * ===================
 *
 *   n+1番目のビットフィールドの探索では、この３つのビットフィールドをOR演算した
 * ビットフィールドを作り、それがONになっている位置は効き筋に当たるので置くことが
 * できない位置ということになります。次にその３つのビットフィールドをORしたビッ
 * トフィールドをビット反転させます。つまり「配置可能なビットがONになったビットフィー
 * ルド」に変換します。そしてこの配置可能なビットフィールドを bitmap と呼ぶとして、
 * 次の演算を行なってみます。
 * 
 * bit = -bitmap & bitmap; //一番右のビットを取り出す
 * 
 *   この演算式の意味を理解するには負の値がコンピュータにおける２進法ではどのよう
 * に表現されているのかを知る必要があります。負の値を２進法で具体的に表わしてみる
 * と次のようになります。
 * 
 *  00000011   3
 *  00000010   2
 *  00000001   1
 *  00000000   0
 *  11111111  -1
 *  11111110  -2
 *  11111101  -3
 * 
 *   正の値nを負の値-nにするときは、nをビット反転してから+1されています。そして、
 * 例えばn=22としてnと-nをAND演算すると下のようになります。nを２進法で表したときの
 * 一番下位のONビットがひとつだけ抽出される結果が得られるのです。極めて簡単な演算
 * によって1ビット抽出を実現させていることが重要です。
 * 
 *      00010110   22
 *  AND 11101010  -22
 * ------------------
 *      00000010
 * 
 *   さて、そこで下のようなwhile文を書けば、このループは bitmap のONビットの数の
 * 回数だけループすることになります。配置可能なパターンをひとつずつ全く無駄がなく
 * 生成されることになります。
 * 
 * while (bitmap) {
 *     bit = -bitmap & bitmap;
 *     bitmap ^= bit;
 *     //ここでは配置可能なパターンがひとつずつ生成される(bit) 
 * }
 */

   /**
    * 実行結果 Java版
   N:            Total       Unique    hh:mm:ss
   2:                0            0  00:00:00
   3:                0            0  00:00:00
   4:                2            1  00:00:00
   5:               10            2  00:00:00
   6:                4            1  00:00:00
   7:               40            6  00:00:00
   8:               92           12  00:00:00
   9:              352           46  00:00:00
  10:              724           92  00:00:00
  11:             2680          341  00:00:00
  12:            14200         1787  00:00:00
  13:            73712         9233  00:00:00
  14:           365596        45752  00:00:00
  15:          2279184       285053  00:00:00
  16:         14772512      1846955  00:00:02
	17:         95815104     11977939  00:00:15
	18:        666090624     83263591  00:01:49
	19:       4968057848    621012754  00:13:55
	20:      39029188884   4878666808  01:50:42
	21:     314666222712  39333324973  15:34:05
	22:    2691008701644 336376244042 136:08:43
  */
]]--


Info={}; Info.new=function()
  local this={
    nTotal=0;nUniq=0; nextCol=0; limit=0;
    starttime=os.clock();
  };
  function Info:resetCount(size)
    self.nTotal,self.nUniq=0,0;
    --self.limit=size;
    self.limit=1;
  end
  function Info:nextJob(nS,nU)
    self.nTotal=self.nTotal+nS;
    self.nUniq=self.nUniq+nU;
    if self.nextCol<self.limit then
      self.nextCol=self.nextCol+1;
    else
      self.nextCol=-1;
    end
    return self.nextCol;
  end
  function Info:getTotal() return self.nTotal; end
  function Info:getUnique() return self.nUniq; end
  function Info:getTime() 
    --print("###"..self.starttime.."###");
    return self:secstotime(os.difftime(os.clock()-self.starttime)); end
  function Info:secstotime(secs)
    if(secs>59) then
      local hour=math.floor(secs*0.000277777778);
      local minute=math.floor(secs*0.0166666667)-hour*60;
      secs=secs-hour*3600-minute*60
      if(secs<10)then secs="0"..secs; end
      if(hour<10)then hour="0"..hour; end
      if(minute<10)then minute="0"..minute; end
      return hour..":"..minute..":"..secs;
    end
    if(secs<10)then secs="0"..secs end
    return "00:00:"..secs;
  end 
  return setmetatable(this,{__index=Info});
end

Thread={}; Thread.new=function()
  local this={
    size=2;
    nTotal=0;nUniq=0;
    BOARD={};
    COUNT2=0;COUNT4=0;COUNT8=0;
    bitt=0;MASK=0;SIZEE=0;TOPBIT=0;
    SIDEMASK=0;LASTMASK=0;ENDBIT=0;
    BOUND1=0;BOUND2=0;
  };
  function Thread:Thread(size,info)
    self.size=size;
    self.info=info;
  end
  function Thread:run()
    local nextCol;
    while(true) do
      nextCol=info:nextJob(self.nTotal,self.nUniq);
      if nextCol<0 then break; end
      self.nTotal,self.nUniq=0,0;
      for row=0,self.size-1,1 do self.BOARD[row]=row; end --テーブルの初期化
      self:bitmap_rotate(self.size);
    end
  end
  function Thread:Check(bsize)
    local _BOARD=0;
    local _BOARD1=self.BOUND1;
    local _BOARD2=self.BOUND2;
    local _BOARDE=self.SIZEE;
    --print("####bsize:"..bsize.."_BOARD1:".._BOARD1.."_BOARD2:".._BOARD2.."_BOARDE:".._BOARDE)  ;
    --90度回転
		if self.BOARD[_BOARD2] == 1 then 
			local own = _BOARD+1;
      --print("90:own:"..own);
      local ptn=2;
      while own <=_BOARDE do
        self.bitt=1;
        local bown=self.BOARD[own];
      --print("90:bown:"..bown);
        local you=_BOARDE;
        while self.BOARD[you] ~= ptn and bown >= self.bitt do
          self.bitt=bit.lshift(self.bitt,1);
          you=you-1;
        end
          --print("90:bitt:"..self.bitt)
        if bown>self.bitt then
          --print("90:return")
          return;
        end
        if bown<self.bitt then
          --print("90:break")
          break;
        end
        own=own+1;
        ptn= bit.lshift(ptn,1);
      end
--			//90度回転して同型なら180度/270度回転も同型である
      if own > _BOARDE then
        self.COUNT2=self.COUNT2 + 1;
        --print("90:count2");
        return;
      end
    end
--		//180度回転
    if bsize == self.ENDBIT then
      local own = _BOARD+1;
      local you=_BOARDE-1;
      --print("180:own:"..own.."you:"..you);
      while own<=_BOARDE do
        self.bitt=1;
        local ptn=self.TOPBIT;
        while ptn~=self.BOARD[you] and self.BOARD[own]>=self.bitt do
          self.bitt=bit.lshift(self.bitt,1);
          ptn=bit.rshift(ptn,1);
        end
        --print("180:bitt:"..self.bitt);
        if self.BOARD[own]>self.bitt then
          --print("180:return");
          return;
        end
        if self.BOARD[own]<self.bitt then
          --print("180:break");
          break;
        end
        own=own+1;
        you=you-1;
      end
--			//90度回転が同型でなくても180度回転が同型である事もある
      if own > _BOARDE then
        self.COUNT4=self.COUNT4 + 1;
        --print("count4:180");
        return;
      end
    end
--		//270度回転
      --print("270:b1"..self.BOARD[_BOARD1].."tb:"..self.TOPBIT);
    if self.BOARD[_BOARD1]==self.TOPBIT then
      local own=_BOARD +1;
      local ptn=bit.rshift(self.TOPBIT,1);
      --print("270:own:"..own.."ptn:"..ptn);
      while own<=_BOARDE do
        self.bitt=1;
        local you=_BOARD;
        while self.BOARD[you]~=ptn and self.BOARD[own]>=self.bitt do
          self.bitt=bit.lshift(self.bitt,1);
          you=you+1;
        end
        if self.BOARD[own]>self.bitt then
          --print("270:rerutn")
          return;
        end
        if self.BOARD[own]<self.bitt then
          --print("270:break")
          break;
        end
        own=own+1;
        ptn=bit.rshift(ptn,1);
      end
    end
          --print("突破:count8")
    self.COUNT8=self.COUNT8+1;
  end   
  --ビット反転させるメソッド・・・😓
  function Thread:rbits(byte,sz)
    local score=0;
    for i=sz,0,-1 do
    --io.write(bit.bnot(bit.band(bit.arshift(byte,i), 1)))
      if bit.band(bit.arshift(byte,i), 1) ==0 then
        score=score+2^i;
      end
    end
    return score;
  end
	 --* 最上段のクイーンが角以外にある場合の探索
  function Thread:backTrack2(y,left,down,right)
--    print("y:"..y.."left:"..left.."down:"..down.."right:"..right);
    local bitmap=bit.band(self.MASK,self:rbits(bit.bor(left,down,right),self.size-1));
--    print("bp1"..bitmap);
    if y==self.SIZEE then
      if bitmap ~=0 then
        if bit.band(bitmap,self.LASTMASK)==0 then
          self.BOARD[y]=bitmap;
--    print("bp2"..bitmap);
          self:Check(bitmap);
        end
      end
    else
      if y<self.BOUND1 then

        bitmap=bit.bor(bitmap,self.SIDEMASK);
--    print("bp3"..bitmap);
        bitmap=bit.bxor(bitmap,self.SIDEMASK);
--    print("bp4"..bitmap);
      elseif y==self.BOUND2 then
        if(bit.band(down,self.SIDEMASK)==0) then
          return;
        end
        if(bit.band(down,self.SIDEMASK)~=self.SIDEMASK) then
          bitmap=bit.band(bitmap,self.SIDEMASK);
--    print("bp5"..bitmap);
        end
      end
      while bitmap ~=0 do
        self.bitt=bit.band(-bitmap,bitmap);
        self.BOARD[y]=self.bitt;
        bitmap=bit.bxor(bitmap,self.BOARD[y]);
--    print("bp6"..bitmap);
--    print("bitt:"..self.bitt);
        self:backTrack2(y+1,bit.lshift(bit.bor(left,self.bitt),1),bit.bor(down,self.bitt),bit.rshift(bit.bor(right,self.bitt),1));
      end
    end
  end
    --	 * 最上段のクイーンが角にある場合の探索
  function Thread:backTrack1(y,left,down,right)
    --print("backTrack1:".."y:"..y.."left:"..left.."down:"..down.."right:"..right);
    local bitmap=bit.band(self.MASK,self:rbits(bit.bor(left,down,right),self.size-1));
  --  print("bitmap:b1:"..bitmap);
    if y==self.SIZEE then
      if bitmap ~=0 then
        self.BOARD[y]=bitmap;
        --print("c8:"..bitmap);
        self.COUNT8=self.COUNT8+1;
      end
    else
      if y<self.BOUND1 then
        bitmap=bit.bor(bitmap,2);
  --      print("bitmap:b2:"..bitmap);
        bitmap=bit.bxor(bitmap,2);
  --      print("bitmap:b3:"..bitmap);
      end
      while bitmap ~=0 do
        self.bitt=bit.band(-bitmap,bitmap);
   --     print("bitmap:b4:bitt:"..self.bitt);
        self.BOARD[y]=self.bitt;
        bitmap=bit.bxor(bitmap,self.BOARD[y]);
    --    print("bitmap:b4:"..bitmap);
        self:backTrack1(y+1,bit.lshift(bit.bor(left,self.bitt),1),bit.bor(down,self.bitt),bit.rshift(bit.bor(right,self.bitt),1));

      end
    end
  end
--
  function Thread:bitmap_rotate(sz)
    self.SIZEE=sz-1;
    self.TOPBIT=bit.lshift(1,self.SIZEE);
    self.MASK=bit.lshift(1,sz)-1;    
    --print("SIZEE:"..self.SIZEE.."TOPBIT:"..self.TOPBIT.."MASK:"..self.MASK);
    self.COUNT8=0;
    self.COUNT4=0;
    self.COUNT2=0;
    self.BOARD[0]=1;
    self.BOUND1=2;
    while self.BOUND1 <self.SIZEE do
      self.bitt=bit.lshift(1,self.BOUND1);
      self.BOARD[1]=self.bitt;
      --print("BOARD[1]:"..self.BOARD[1].."bit:"..self.bitt);
      self:backTrack1(2,bit.lshift(bit.bor(2,self.bitt),1),bit.bor(1,self.bitt),bit.rshift(self.bitt,1));
      self.BOUND1=self.BOUND1+1;
    end
    self.LASTMASK=bit.bor(self.TOPBIT,1);
    self.SIDEMASK=self.LASTMASK;    
    self.ENDBIT=bit.rshift(self.TOPBIT,1);
    self.BOUND1=1;
    self.BOUND2=sz-2;
    --print("LM:"..self.LASTMASK.."SM:"..self.SIDEMASK.."EB:"..self.ENDBIT.."B2:"..self.BOUND2);
    while self.BOUND1<self.BOUND2 do
      self.bitt=bit.lshift(1,self.BOUND1);
      self.BOARD[0]=self.bitt;
     -- print("bit:"..self.bitt.."board[0]:"..self.BOARD[0]);
      self:backTrack2(1,bit.lshift(self.bitt,1),self.bitt,bit.rshift(self.bitt,1));
      self.LASTMASK=bit.bor(self.LASTMASK,bit.rshift(self.LASTMASK,1),bit.lshift(self.LASTMASK,1));
      self.ENDBIT=bit.rshift(self.ENDBIT,1);
      --print("LM:"..self.LASTMASK.."EB:"..self.ENDBIT);
      self.BOUND1=self.BOUND1+1;
      self.BOUND2=self.BOUND2-1;
    end
    --print("c2:"..self.COUNT2.."c4:"..self.COUNT4.."c8:"..self.COUNT8);
    self.nUniq=self.COUNT8+self.COUNT4+self.COUNT2;
    self.nTotal=(self.COUNT8*8)+(self.COUNT4*4)+(self.COUNT2*2);
  end

  return setmetatable(this,{__index=Thread});
end


NQueen={}; NQueen.new=function()
  local this={ 
    max=27; size=2; 
  };
  function NQueen:NQueen()
    print(" N:            Total       Unique    mm:ss:ms");
    for size=2,self.max,1 do
      info=Info.new(); 
      info:resetCount();
      thread=Thread.new();
      thread:Thread(size,info);   
      thread:run();
      print(string.format("%2d:%17d%13d%12s", size,info:getTotal(),info:getUnique(),info:getTime())); 
    end
  end
  return setmetatable(this,{__index=NQueen} );
end

NQueen.new():NQueen();


