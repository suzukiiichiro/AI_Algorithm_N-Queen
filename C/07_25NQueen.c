/**
  Cで学ぶアルゴリズムとデータ構造  
  ステップバイステップでＮ−クイーン問題を最適化
  一般社団法人  共同通信社  情報技術局  鈴木  維一郎(suzuki.iichiro@kyodonews.jp)
  
   １．ブルートフォース（力まかせ探索） NQueen01() N8=16,777,216通り
   ２．配置フラグ（制約テスト高速化）   NQueen02() N8=    40,320通り
   ３．バックトラック                   NQueen03() N17= 12:29.59
   ４．対称解除法(回転と斜軸）          NQueen04() N17=  8:11.18
   ５．枝刈りと最適化                   NQueen05() N17=  2:40.86
   ６．ビットマップ                     NQueen06() N17=  1:23.70
   ７．ビットマップ+対称解除法          NQueen07() N17=  2:41.67
   ８．ビットマップ+クイーンの場所で分岐NQueen08() N17=  1:36.28
   ９．ビットマップ+枝刈りと最適化      NQueen09() N17=    15.77
   10．もっとビットマップ(takaken版)    NQueen10() N17=    19.16
   11．マルチスレッド(構造体)           NQueen11() N17=    15.57
   12．マルチスレッド(pthread)          NQueen12() N17=    15.47
   13．マルチスレッド(mutex)            NQueen13() N17=    15.65
   14．マルチスレッド(mutexattr)        NQueen14() N17=    07.07
   15．マルチスレッド(脱mutex COUNT強化)NQueen15() N17=    04.15
   15t.もっとマルチスレッド(takaken版) NQueen15_t()N17=    12.59 
   16．アドレスとポインタ(考察１)       NQueen16() N17=    04.11
   17．アドレスとポインタ(考察２)       NQueen17() N17=    05.48
   18．アドレスとポインタ(考察３)       NQueen18() N17=    05.71
   19．アドレスとポインタ(考察４)       NQueen19() N17=    03.66
   20．アドレスとポインタ(考察５)       NQueen20() N17=    03.82
   21．アドレスとポインタ(考察６)       NQueen21() N17=    03.80
   22．アドレスとポインタ(考察７)       NQueen22() N17=    03.85
   23．アドレスとポインタ(考察８)       NQueen23() N17=    03.73
   24．アドレスとポインタ(完結)         NQueen24() N17=    03.73
 <>25．最適化 									        NQueen25() N17=    03.70

 # Java/C/Lua/Bash版
 # https://github.com/suzukiiichiro/N-Queen
 
*************************
はじめに
*************************

幸運にもこのページを参照することができたN-Queen(Nクイーン）エンジニアは少数だろう。
Google検索またはGit検索でたどり着いたのだとは思うが、確率は奇跡に近い。
エンジニアにしてこのページを参照できた奇跡ついでにもう少しだけ読み進めて欲しい。
具体的には以下のリンクにわかりやすく書いてある。

  エイト・クイーン問題
  https://ja.wikipedia.org/wiki/エイト・クイーン
 
エイト・クイーンは、名前の通り８つのクイーンの解を求めるというパズルである。
Nクイーンは、エイトクイーンの拡張版で、Nの値は８、９、１０，１１，１２･･･と言った風
に増え続け、そのNの値であるボードの解を求めるものである。

GooleなどWebを探索すると無数のページがあることがわかる。その中でも充実したサイトを
紹介したい。おおよそ以下のサイトをかみしめて読み解けば情報は９０％網羅されている。

N-Queens 問題(Nobuhide Tsudaさん)
*************************
  はじめに
  力まかせ探索（Brute-force search）
  バックトラッキング
  制約テスト高速化（配置フラグ）
  ビット演算（ビットマップ）による高速化
  対称解除去
  枝刈りによる高速化
  http://vivi.dyndns.org/tech/puzzle/NQueen.html

Puzzle DE Programming(M.Hiroiさん）
*************************
  バックトラックとビット演算による高速化
  http://www.geocities.jp/m_hiroi/puzzle/nqueens.html

takakenさん（高橋謙一郎さん）のページ
*************************
  Ｎクイーン問題（解の個数を求める）
    ビット処理を用いた基本形
    ビット処理を用いたプログラムの仕組み
    ユニーク解の判定方法
    ユニーク解の個数を求める
    ユニーク解から全解への展開
    ソースプログラムと実行結果
  http://www.ic-net.or.jp/home/takaken/nt/queen/index.html

の、みなさんが掲示板で議論している模様(貴重ですね）
http://www2.ic-net.or.jp/~takaken/auto/guest/bbs62.html

ptimal Queens
*************************
英語だが、上記の全てがJavaで書かれていて群を抜いている
http://penguin.ewu.edu/~trolfe/Queens/OptQueen.html

その他のリンク
https://rosettacode.org/wiki/N-queens_problem
http://www.cc.kyoto-su.ac.jp/~yamada/ap/backtrack.html
http://yucchi.jp/java/java_tip/n_queens_problem/n_queens_problem.html
http://www.shido.info/py/queen_py3.html
http://toraneko75.sakura.ne.jp/wp/?p=223
http://yoshiiz.blog129.fc2.com/blog-entry-380.html
http://nw.tsuda.ac.jp/class/algoB/c6.html
http://www.kawa.net/works/js/8queens/nqueens.html
http://www.yasugi.ai.kyutech.ac.jp/2012/4/nq.html
http://www.neuro.sfc.keio.ac.jp/~masato/jv/nqueen/MPneuron.java
http://fujimura2.fiw-web.net/java/lang/page-20-3.html
https://github.com/pankajmore/DPP/blob/master/EPI/src/puzzles/NQueens.java
http://www.kanadas.com/ccm/queens-sort/index-j.html
http://chiiji.s10.xrea.com/nn/nqueen/nqueenn.shtml
http://www.neuro.sfc.keio.ac.jp/~masato/jv/nqueen/nqueenDemo.htm


ここからは参考情報のメモとして

ビットマップを N-Queens に最初に応用したのは Jeff Somers 氏のようだ。 
参照：The N Queens Problem
http://www.jsomers.com/nqueen_demo/nqueens.html(リンク切れのようだ）

電気通信大学　N-queensとは
2004年、電気通信大学の研究グループが、処理を並列化し、N=24 の解の個数を世界で初めて発見。 
http://www.arch.cs.titech.ac.jp/~kise/nq/
プレスリリース
http://www.arch.cs.titech.ac.jp/~kise/nq/press-2004-10-05.txt

NQueens問題
ＱＪＨの基本構想は、”部分解から全体解を構成するというアプローチ”（部分解合成法：Ｐａｒts Assembly Approach)です。
http://deepgreen.game.coocan.jp/NQueens/nqueen_index.htm

N Queens World records
http://www.nqueens.de/sub/WorldRecord.en.html


*****************************
このぺーじにはなにがあるのか
*****************************

具体的にこのページにはNクイーンのプログラムがある。
少なくともこの（今見ているこのページだ）１枚を実行すればまたたくまに処理は実行され問題は解決される。
ためしにこのページを  NQueen.c という名前で保存して自分のターミナル（それがわかる人に限定される）で、

コンパイル
$ gcc -pthread -O3 -Wall NQueen.c -o NQueen 

実行
$ ./NQueen 


を試して欲しい。実はこのページは 07の14ステップ目のソースである。ではそのステップを以下に示す。

Nクイーンの解決には処理を分解して一つ一つ丁寧に理解すべくステップが必要だ。
最初はステップ１のソースを何度も見て書いて理解するしかない。
もちろん、簡単なだけに解決時間も相当かかる。処理が終わるまでにコーヒーが飲み終わってしまうかもしれない。
ステップ15までくると、およそ１秒もかからずに処理が終了する。１分かかっていたことが１秒で終わることに
興味がわかないかもしれない。がしかし、１００年かかることが１年かからないとしたらどうだろう。
人工知能AI技術は、デバイスの進化、処理の高速化、解法の最適化（アルゴリズム）の三位一体だ。
順番に、とばすことなくじっくりと読み進めて欲しい。たぶん、日本中のNクイーンプログラムをここまで分解して
ステップにまとめているサイトはそう多くはないはずだ。

さらに、このサイトはNクイーンプログラムを複数のプログラム言語で習熟出来る準備がある。
例えば以下の通りだ。

  Java版 N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_N-Queen

  Bash版 N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_Bash

  Lua版  N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_Lua

  C版  N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_C
 

C版
　およそ全てのプログラム言語の中で最も高速に処理できると言われている。事実そうだ。
　まだ何もわからない初学の人はC言語から始めるべきだ。
　マルチスレッドなど、Javaに比べて複雑に記述する必要がある分、プログラムの端々までの
深い知識が必要だ。C言語マスターは間違いなく、Javaプログラマよりシステム技術を網羅的に深く理解している。

Java版
　C言語があまりにも難解と言われ、取っつきやすい部分を残し、Cでできることを取りこぼさずにできた言語がJavaだ。
マルチスレッドも、C言語よりもわかりやすい。システム技術の表層的な知識だけしかないのであればJavaがよい。
システムがわかった気になる危険な言語でもある。結論から言えばJavaができてもLinuxコマンドやBash、カーネルの
理解は１つも進まない。

Bash版
Linux/UNIXを学ぶのであればBash版をおすすめする。
https://github.com/suzukiiichiro/AI_Algorithm_Bash

  なぜBashなのかは以下に書いておいた。
  https://github.com/suzukiiichiro/AI_Algorithm_Bash/blob/master/002UNIXBasic

Bashは遅い。だが強力だ。Linuxの力を手に入れることができる。
どの言語で学ぶのかを迷っているのであれば迷わず「Bash」を選んで欲しい。
その次はLua->Java->Cだ。

Lua版
スマートフォンアプリが世の中のテクノロジーを牽引しているのは間違いない。
そのアプリ開発で幅を利かせているのがLua言語だ。コンパクトで高速、周りとの相性も良いときている。


上記、どの言語から始めても良いと思う。できる人はどの言語でもすらすら書ける。
では、以下から本題に入る。


*****************************
  N-Queens問題とは
*****************************
 
     Nクイーン問題とは、「8列×8行のチェスボードに8個のクイーンを、互いに効きが
     当たらないように並べよ」という８クイーン問題のクイーン(N)を、どこまで大き
     なNまで解を求めることができるかという問題。
     クイーンとは、チェスで使われているクイーンを指し、チェス盤の中で、縦、横、
     斜めにどこまでも進むことができる駒で、日本の将棋でいう「飛車と角」を合わ
     せた動きとなる。８列×８行で構成される一般的なチェスボードにおける8-Queens
     問題の解は、解の総数は92個である。比較的単純な問題なので、学部レベルの演
     習問題として取り上げられることが多い。
     8-Queens問題程度であれば、人力またはプログラムによる「力まかせ探索」でも
     解を求めることができるが、Nが大きくなると解が一気に爆発し、実用的な時間で
     は解けなくなる。
     現在すべての解が判明しているものは、2004年に電気通信大学でIntel Pentium 4
     Xeon 2.8GHzのプロセッサを68個搭載するPCクラスタ×20日をかけてn=24を解決し、
     世界一に、その後2005 年にニッツァ大学でn=25、2009年にドレスデン工科大学で
     N-26、さらに2016年に同工科大学でN=27の解を求めることに成功している。
     JeffSommers氏のビット演算を用いたエレガントなアルゴリズムに加え、対称解除
     法、並列処理、部分解合成法、圧縮や枝刈りなど、先端技術でワールドレコードが
     次々と更新されている。

             Total解        Unique解    鈴木維版   QJH(GPU)版   高橋謙一郎版  電通大版  JeffSomers版
15         2,279,184         285,053    00:00:00     00:00:00     00:00:00    00:00:01    00:00:04
16        14,772,512       1,846,955    00:00:00     00:00:00     00:00:04    00:00:08    00:00:23
17        95,815,104      11,977,939    00:00:04     00:00:07     00:00:31    00:01:01    00:02:38
18       666,090,624      83,263,591    00:00:33     00:00:25     00:03:48    00:07:00    00:19:26
19     4,968,057,848     621,012,754    00:04:19     00:03:17     00:29:22    00:57:16    02:31:24
20    39,029,188,884   4,878,666,808    00:34:49     00:24:07     03:54:10    07:19:24    20:35:06
21   314,666,222,712  39,333,324,973    04:41:36     03:05:28  01:09:17:19
22 2,691,008,701,644 336,376,244,042 01:15:14:59  01:03:08:20                   22日
23
24 ２００４年４月１１日 電気通信大学　2009年4月68CPU x 22日
25 ２００５年６月１１日 ProActive      単一CPU換算で５０年以上                                           
26 ２００９年７月１１日 tu-dresden     FPGA ( *1 : 8*22 2.5 GHz-QuadCore systemsに相当（約176 * 4CPU = 704 CPU))  x ２４０日
27 ２０１６年　月　　日 tu-dresden




************************************************
  ステップバイステップでＮ−クイーン問題を最適化
************************************************

 1. ブルートフォース　力任せ探索

 　全ての可能性のある解の候補を体系的に数え上げ、それぞれの解候補が問題の解と
   なるかをチェックする方法
   (※)各行に１個の王妃を配置する組み合わせを再帰的に列挙組み合わせを生成するだ
   けであって8王妃問題を解いているわけではありません

  実行結果
  :
  :
  16777207: 7 7 7 7 7 7 6 6
  16777208: 7 7 7 7 7 7 6 7
  16777209: 7 7 7 7 7 7 7 0
  16777210: 7 7 7 7 7 7 7 1
  16777211: 7 7 7 7 7 7 7 2
  16777212: 7 7 7 7 7 7 7 3
  16777213: 7 7 7 7 7 7 7 4
  16777214: 7 7 7 7 7 7 7 5
  16777215: 7 7 7 7 7 7 7 6
  16777216: 7 7 7 7 7 7 7 7


  ２．配置フラグ（制約テスト高速化）
   パターンを生成し終わってからチェックを行うのではなく、途中で制約を満たさな
   い事が明らかな場合は、それ以降のパターン生成を行わない。
  「手を進められるだけ進めて、それ以上は無理（それ以上進めても解はない）という
  事がわかると一手だけ戻ってやり直す」という考え方で全ての手を調べる方法。
  (※)各行列に一個の王妃配置する組み合わせを再帰的に列挙分枝走査を行っても、組
  み合わせを列挙するだけであって、8王妃問題を解いているわけではありません。
 
  実行結果
  :
  :
  40312: 7 6 5 4 2 1 3 0
  40313: 7 6 5 4 2 3 0 1
  40314: 7 6 5 4 2 3 1 0
  40315: 7 6 5 4 3 0 1 2
  40316: 7 6 5 4 3 0 2 1
  40317: 7 6 5 4 3 1 0 2
  40318: 7 6 5 4 3 1 2 0
  40319: 7 6 5 4 3 2 0 1
  40320: 7 6 5 4 3 2 1 0


  ３．バックトラック
   　各列、対角線上にクイーンがあるかどうかのフラグを用意し、途中で制約を満た
   さない事が明らかな場合は、それ以降のパターン生成を行わない。
   　各列、対角線上にクイーンがあるかどうかのフラグを用意することで高速化を図る。
   　これまでは行方向と列方向に重複しない組み合わせを列挙するものですが、王妃
   は斜め方向のコマをとることができるので、どの斜めライン上にも王妃をひとつだ
   けしか配置できない制限を加える事により、深さ優先探索で全ての葉を訪問せず木
   を降りても解がないと判明した時点で木を引き返すということができます。
 
 
  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               0            0.00
 5:           10               0            0.00
 6:            4               0            0.00
 7:           40               0            0.00
 8:           92               0            0.00
 9:          352               0            0.00
10:          724               0            0.00
11:         2680               0            0.01
12:        14200               0            0.05
13:        73712               0            0.30
14:       365596               0            1.93
15:      2279184               0           13.50
16:     14772512               0         1:39.30
17:     95815104               0        12:29.59


 ４．対称解除法
     一つの解には、盤面を９０度、１８０度、２７０度回転、及びそれらの鏡像の合計
     ８個の対称解が存在する。対照的な解を除去し、ユニーク解から解を求める手法。
 
 ■ユニーク解の判定方法
   全探索によって得られたある１つの解が、回転・反転などによる本質的に変わること
 のない変換によって他の解と同型となるものが存在する場合、それを別の解とはしない
 とする解の数え方で得られる解を「ユニーク解」といいます。つまり、ユニーク解とは、
 全解の中から回転・反転などによる変換によって同型になるもの同士をグループ化する
 ことを意味しています。
 
   従って、ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、こ
 の解はユニーク解ではないという定まった判定方法はありません。ユニーク解であるか
 どうかの判断はユニーク解の個数を数える目的の為だけに各個人が自由に定義すること
 になります。もちろん、どのような定義をしたとしてもユニーク解の個数それ自体は変
 わりません。
 
   さて、Ｎクイーン問題は正方形のボードで形成されるので回転・反転による変換パター
 ンはぜんぶで８通りあります。だからといって「全解数＝ユニーク解数×８」と単純には
 いきません。ひとつのグループの要素数が必ず８個あるとは限らないのです。Ｎ＝５の
 下の例では要素数が２個のものと８個のものがあります。


 Ｎ＝５の全解は１０、ユニーク解は２なのです。
 
 グループ１: ユニーク解１つ目
--- Q-  - Q---
 Q----  ---- Q
-- Q--  -- Q--
---- Q   Q----
- Q---  --- Q-
 
 グループ２: ユニーク解２つ目
---- Q   Q----  -- Q--  -- Q--  --- Q-  - Q---   Q----  ---- Q
-- Q--  -- Q--   Q----  ---- Q  - Q---  --- Q-  --- Q-  - Q---
 Q----  ---- Q  --- Q-  - Q---  ---- Q   Q----  - Q---  --- Q-
--- Q-  - Q---  - Q---  --- Q-  -- Q--  -- Q--  ---- Q   Q----
- Q---  --- Q-  ---- Q   Q----   Q----  ---- Q  -- Q--  -- Q--

 
   それでは、ユニーク解を判定するための定義付けを行いますが、次のように定義する
 ことにします。各行のクイーンが右から何番目にあるかを調べて、最上段の行から下
 の行へ順番に列挙します。そしてそれをＮ桁の数値として見た場合に最小値になるもの
 をユニーク解として数えることにします。尚、このＮ桁の数を以後は「ユニーク判定値」
 と呼ぶことにします。
 
---- Q   0
-- Q--   2
 Q----   4  --->  0 2 4 1 3 (ユニーク判定値)
--- Q-   1
- Q---   3
 
 
   探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定
 するには「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるか
 を調べる」ことになります。しかし結論から先にいえば、ユニーク解とは成り得ないこ
 とが明確なパターンを探索中に切り捨てるある枝刈りを組み込むことにより、３通りの
 変換を試みるだけでユニーク解の判定が可能になります。
  
 
 ■ユニーク解の個数を求める
   先ず最上段の行のクイーンの位置に着目します。その位置が左半分の領域にあればユ
 ニーク解には成り得ません。何故なら左右反転によって得られるパターンのユニーク判
 定値の方が確実に小さくなるからです。また、Ｎが奇数の場合に中央にあった場合はど
 うでしょう。これもユニーク解には成り得ません。何故なら仮に中央にあった場合、そ
 れがユニーク解であるためには少なくとも他の外側の３辺におけるクイーンの位置も中
 央になければならず、それは互いの効き筋にあたるので有り得ません。


 ***********************************************************************
 最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
 ***********************************************************************
 
   次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。他の３つ
 の角にクイーンを置くことはできないので(効き筋だから）、ユニーク解であるかどうか
 を判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになり
 ます。突き詰めれば、
 
 [上から２行目のクイーンの位置が右から何番目にあるか]
 [右から２列目のクイーンの位置が上から何番目にあるか]
 

 を比較するだけで判定することができます。この２つの値が同じになることはないからです。
 
       3 0
       ↓↓
---- Q ←0
- Q--- ←3
-----         上から２行目のクイーンの位置が右から４番目にある。
--- Q-         右から２列目のクイーンの位置が上から４番目にある。
-----         しかし、互いの効き筋にあたるのでこれは有り得ない。
 
   結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得
 られる解は総てユニーク解であることが保証されます。
 
---- X Q
- Q-- X-
---- X-
---- X-
------
------
 
   次に右端以外にクイーンがある場合を考えてみます。オリジナルがユニーク解である
 ためには先ず下図の X への配置は禁止されます。よって、その枝刈りを先ず入れておき
 ます。
 
 X X--- Q X X
 X------ X
--------
--------
--------
--------
 X------ X
 X X---- X X
 
   次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能
 性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。従っ
 て、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいこと
 になります。
 
 X X x x x Q X X
 X--- x x x X
 C-- x- x- x
-- x-- x--
- x--- x--
 x---- x- A
 X---- x- X
 X X B-- x X X


 ■ユニーク解から全解への展開
   これまでの考察はユニーク解の個数を求めるためのものでした。全解数を求めるには
 ユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。したがって
 探索時間を犠牲にしてしまうことになります。そこで「ユニーク解の個数から全解数を
 導いてしまおう」という試みが考えられます。これは、左右反転によるパターンの探索
 を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。そしてそ
 れを実現させるには「あるユニーク解が属するグループの要素数はいくつあるのか」と
 いう考察が必要になってきます。
 
   最初に、クイーンが右上角にあるユニーク解を考えます。斜軸で反転したパターンが
 オリジナルと同型になることは有り得ないことと(×２)、右上角のクイーンを他の３つの
 角に写像させることができるので(×４)、このユニーク解が属するグループの要素数は必
 ず８個(＝２×４)になります。
 
   次に、クイーンが右上角以外にある場合は少し複雑になりますが、考察を簡潔にする
 ために次の事柄を確認します。

 TOTAL=(COUNT8 * 8)+(COUNT4 * 4)+(COUNT2 * 2);
  (1)90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
    ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
    ジナルと同型になる。  

    COUNT2 * 2
 
  (2)90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナ
    ルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有
    り得る。 

    COUNT4 * 4
 
  (3)(1)に該当するユニーク解が属するグループの要素数は、左右反転させたパターンを
       加えて２個しかありません。(2)に該当するユニーク解が属するグループの要素数は、
       180度回転させて同型になる場合は４個(左右反転×縦横回転)、そして180度回転させても
       オリジナルと異なる場合は８個になります。(左右反転×縦横回転×上下反転)
 
    COUNT8 * 8 

   以上のことから、ひとつひとつのユニーク解が上のどの種類に該当するのかを調べる
 ことにより全解数を計算で導き出すことができます。探索時間を短縮させてくれる枝刈
 りを外す必要がなくなったというわけです。 
 
   UNIQUE  COUNT2     +  COUNT4     +  COUNT8
   TOTAL (COUNT2 * 2)+(COUNT4 * 4)+(COUNT8 * 8)

 　これらを実現すると、前回のNQueen3()よりも実行速度が遅くなります。
 　なぜなら、対称・反転・斜軸を反転するための処理が加わっているからです。
 ですが、今回の処理を行うことによって、さらにNQueen5()では、処理スピードが飛躍的に高速化されます。そのためにも今回のアルゴリズム実装は必要なのです。

  実行結果
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:02
15:      2279184          285053      0 00:00:10
16:     14772512         1846955      0 00:01:10
17:     95815104        11977939      0 00:08:18



 * ５．枝刈りと最適化
 * 　単純ですのでソースのコメントを見比べて下さい。
 *   単純ではありますが、枝刈りの効果は絶大です。

   実行結果
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:03
16:     14772512         1846955      0 00:00:20
17:     95815104        11977939      0 00:02:31


 ６．ビットマップ
   ビット演算を使って高速化 状態をビットマップにパックし、処理する
   単純なバックトラックよりも２０〜３０倍高速
 
 　ビットマップであれば、シフトにより高速にデータを移動できる。
  フラグ配列ではデータの移動にO(N)の時間がかかるが、ビットマップであればO(1)
  フラグ配列のように、斜め方向に 2*N-1の要素を用意するのではなく、Nビットで充
  分。

 　配置可能なビット列を flags に入れ、-flags & flags で順にビットを取り出し処理。
 　バックトラックよりも２０−３０倍高速。
 
 ===================
 考え方 1
 ===================

 　Ｎ×ＮのチェスボードをＮ個のビットフィールドで表し、ひとつの横列の状態をひと
 つのビットフィールドに対応させます。(クイーンが置いてある位置のビットをONに
 する)
 　そしてバックトラッキングは0番目のビットフィールドから「下に向かって」順にい
 ずれかのビット位置をひとつだけONにして進めていきます。

 
  - - - - - Q - -    00000100 0番目のビットフィールド
  - - - Q - - - -    00010000 1番目のビットフィールド
  - - - - - - Q -    00000010 2番目のビットフィールド
  Q - - - - - - -    10000000 3番目のビットフィールド
  - - - - - - - Q    00000001 4番目のビットフィールド
  - Q - - - - - -    01000000 5番目のビットフィールド
  - - - - Q - - -    00001000 6番目のビットフィールド
  - - Q - - - - -    00100000 7番目のビットフィールド


 ===================
 考え方 2
 ===================

 次に、効き筋をチェックするためにさらに３つのビットフィールドを用意します。

 1. 左下に効き筋が進むもの: left 
 2. 真下に効き筋が進むもの: down
 3. 右下に効き筋が進むもの: right

次に、斜めの利き筋を考えます。
 上図の場合、
 1列目の右斜め上の利き筋は 3 番目 (0x08)
 2列目の右斜め上の利き筋は 2 番目 (0x04) になります。
 この値は 0 列目のクイーンの位置 0x10 を 1 ビットずつ「右シフト」すれば求める
 ことができます。
 また、左斜め上の利き筋の場合、1 列目では 5 番目 (0x20) で 2 列目では 6 番目 (0x40)
になるので、今度は 1 ビットずつ「左シフト」すれば求めることができます。

つまり、右シフトの利き筋を right、左シフトの利き筋を left で表すことで、クイー
ンの効き筋はrightとleftを1 ビットシフトするだけで求めることができるわけです。

  *-------------
  | . . . . . .
  | . . . -3. .  0x02 -|
  | . . -2. . .  0x04  |(1 bit 右シフト right)
  | . -1. . . .  0x08 -|
  | Q . . . . .  0x10 ←(Q の位置は 4   down)
  | . +1. . . .  0x20 -| 
  | . . +2. . .  0x40  |(1 bit 左シフト left)  
  | . . . +3. .  0x80 -|
  *-------------
  図：斜めの利き筋のチェック

 n番目のビットフィールドからn+1番目のビットフィールドに探索を進めるときに、そ
 の３つのビットフィールドとn番目のビットフィールド(bit)とのOR演算をそれぞれ行
 います。leftは左にひとつシフトし、downはそのまま、rightは右にひとつシフトして
 n+1番目のビットフィールド探索に渡してやります。

 left : (left |bit)<<1
 right: (right|bit)>>1
 down :   down|bit


 ===================
 考え方 3
 ===================

   n+1番目のビットフィールドの探索では、この３つのビットフィールドをOR演算した
 ビットフィールドを作り、それがONになっている位置は効き筋に当たるので置くことが
 できない位置ということになります。次にその３つのビットフィールドをORしたビッ
 トフィールドをビット反転させます。つまり「配置可能なビットがONになったビットフィー
 ルド」に変換します。そしてこの配置可能なビットフィールドを bitmap と呼ぶとして、
 次の演算を行なってみます。
 
 bit = -bitmap & bitmap; //一番右のビットを取り出す
 
   この演算式の意味を理解するには負の値がコンピュータにおける２進法ではどのよう
 に表現されているのかを知る必要があります。負の値を２進法で具体的に表わしてみる
 と次のようになります。
 
  00000011   3
  00000010   2
  00000001   1
  00000000   0
  11111111  -1
  11111110  -2
  11111101  -3
 
   正の値nを負の値-nにするときは、nをビット反転してから+1されています。そして、
 例えばn=22としてnと-nをAND演算すると下のようになります。nを２進法で表したときの
 一番下位のONビットがひとつだけ抽出される結果が得られるのです。極めて簡単な演算
 によって1ビット抽出を実現させていることが重要です。
 
      00010110   22
  AND 11101010  -22
 ------------------
      00000010
 
   さて、そこで下のようなwhile文を書けば、このループは bitmap のONビットの数の
 回数だけループすることになります。配置可能なパターンをひとつずつ全く無駄がなく
 生成されることになります。
 
 while (bitmap) {
     bit = -bitmap & bitmap;
     bitmap ^= bit;
     //ここでは配置可能なパターンがひとつずつ生成される(bit) 
 }


 ６．ビットマップ
  実行結果
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:02
16:     14772512         1846955      0 00:00:11
17:     95815104        11977939      0 00:01:18


 <>７．ビットマップ+対称解除法          NQueen07() N17: 2:24
 *
 *     一つの解には、盤面を９０度、１８０度、２７０度回転、及びそれらの鏡像の合計
 *     ８個の対称解が存在する。対照的な解を除去し、ユニーク解から解を求める手法。
 * 
 * ■ユニーク解の判定方法
 *   全探索によって得られたある１つの解が、回転・反転などによる本質的に変わること
 * のない変換によって他の解と同型となるものが存在する場合、それを別の解とはしない
 * とする解の数え方で得られる解を「ユニーク解」といいます。つまり、ユニーク解とは、
 * 全解の中から回転・反転などによる変換によって同型になるもの同士をグループ化する
 * ことを意味しています。
 * 
 *   従って、ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、こ
 * の解はユニーク解ではないという定まった判定方法はありません。ユニーク解であるか
 * どうかの判断はユニーク解の個数を数える目的の為だけに各個人が自由に定義すること
 * になります。もちろん、どのような定義をしたとしてもユニーク解の個数それ自体は変
 * わりません。
 * 
 *   さて、Ｎクイーン問題は正方形のボードで形成されるので回転・反転による変換パター
 * ンはぜんぶで８通りあります。だからといって「全解数＝ユニーク解数×８」と単純には
 * いきません。ひとつのグループの要素数が必ず８個あるとは限らないのです。Ｎ＝５の
 * 下の例では要素数が２個のものと８個のものがあります。
 *
 *
 * Ｎ＝５の全解は１０、ユニーク解は２なのです。
 * 
 * グループ１: ユニーク解１つ目
 * - - - Q -   - Q - - -
 * Q - - - -   - - - - Q
 * - - Q - -   - - Q - -
 * - - - - Q   Q - - - -
 * - Q - - -   - - - Q -
 * 
 * グループ２: ユニーク解２つ目
 * - - - - Q   Q - - - -   - - Q - -   - - Q - -   - - - Q -   - Q - - -   Q - - - -   - - - - Q
 * - - Q - -   - - Q - -   Q - - - -   - - - - Q   - Q - - -   - - - Q -   - - - Q -   - Q - - -
 * Q - - - -   - - - - Q   - - - Q -   - Q - - -   - - - - Q   Q - - - -   - Q - - -   - - - Q -
 * - - - Q -   - Q - - -   - Q - - -   - - - Q -   - - Q - -   - - Q - -   - - - - Q   Q - - - -
 * - Q - - -   - - - Q -   - - - - Q   Q - - - -   Q - - - -   - - - - Q   - - Q - -   - - Q - -
 *
 * 
 *   それでは、ユニーク解を判定するための定義付けを行いますが、次のように定義する
 * ことにします。各行のクイーンが右から何番目にあるかを調べて、最上段の行から下
 * の行へ順番に列挙します。そしてそれをＮ桁の数値として見た場合に最小値になるもの
 * をユニーク解として数えることにします。尚、このＮ桁の数を以後は「ユニーク判定値」
 * と呼ぶことにします。
 * 
 * - - - - Q   0
 * - - Q - -   2
 * Q - - - -   4   --->  0 2 4 1 3  (ユニーク判定値)
 * - - - Q -   1
 * - Q - - -   3
 * 
 * 
 *   探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定
 * するには「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるか
 * を調べる」ことになります。しかし結論から先にいえば、ユニーク解とは成り得ないこ
 * とが明確なパターンを探索中に切り捨てるある枝刈りを組み込むことにより、３通りの
 * 変換を試みるだけでユニーク解の判定が可能になります。
 *  
 * 
  実行結果
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:03
16:     14772512         1846955      0 00:00:21
17:     95815104        11977939      0 00:02:30


 ８．ビットマップ＋クイーンの場所で分岐
 *
 * ■ユニーク解の個数を求める
 *   先ず最上段の行のクイーンの位置に着目します。その位置が左半分の領域にあればユ
 * ニーク解には成り得ません。何故なら左右反転によって得られるパターンのユニーク判
 * 定値の方が確実に小さくなるからです。また、Ｎが奇数の場合に中央にあった場合はど
 * うでしょう。これもユニーク解には成り得ません。何故なら仮に中央にあった場合、そ
 * れがユニーク解であるためには少なくとも他の外側の３辺におけるクイーンの位置も中
 * 央になければならず、それは互いの効き筋にあたるので有り得ません。
 *
 *
 * ***********************************************************************
 * 最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
 * ***********************************************************************
 * 
 *   次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。他の３つ
 * の角にクイーンを置くことはできないので(効き筋だから）、ユニーク解であるかどうか
 * を判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになり
 * ます。突き詰めれば、
 * 
 * [上から２行目のクイーンの位置が右から何番目にあるか]
 * [右から２列目のクイーンの位置が上から何番目にあるか]
 * 
 *
 * を比較するだけで判定することができます。この２つの値が同じになることはないからです。
 * 
 *       3 0
 *       ↓↓
 * - - - - Q ←0
 * - Q - - - ←3
 * - - - - -         上から２行目のクイーンの位置が右から４番目にある。
 * - - - Q -         右から２列目のクイーンの位置が上から４番目にある。
 * - - - - -         しかし、互いの効き筋にあたるのでこれは有り得ない。
 * 
 *   結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得
 * られる解は総てユニーク解であることが保証されます。
 * 
 * - - - - X Q
 * - Q - - X -
 * - - - - X -
 * - - - - X -
 * - - - - - -
 * - - - - - -
 * 
 *   次に右端以外にクイーンがある場合を考えてみます。オリジナルがユニーク解である
 * ためには先ず下図の X への配置は禁止されます。よって、その枝刈りを先ず入れておき
 * ます。
 * 
 * X X - - - Q X X
 * X - - - - - - X
 * - - - - - - - -
 * - - - - - - - -
 * - - - - - - - -
 * - - - - - - - -
 * X - - - - - - X
 * X X - - - - X X
 * 
 *   次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能
 * 性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。従っ
 * て、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいこと
 * になります。
 * 
 * X X x x x Q X X
 * X - - - x x x X
 * C - - x - x - x
 * - - x - - x - -
 * - x - - - x - -
 * x - - - - x - A
 * X - - - - x - X
 * X X B - - x X X
 *
 *
 * ■ユニーク解から全解への展開
 *   これまでの考察はユニーク解の個数を求めるためのものでした。全解数を求めるには
 * ユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。したがって
 * 探索時間を犠牲にしてしまうことになります。そこで「ユニーク解の個数から全解数を
 * 導いてしまおう」という試みが考えられます。これは、左右反転によるパターンの探索
 * を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。そしてそ
 * れを実現させるには「あるユニーク解が属するグループの要素数はいくつあるのか」と
 * いう考察が必要になってきます。
 * 
 *   最初に、クイーンが右上角にあるユニーク解を考えます。斜軸で反転したパターンが
 * オリジナルと同型になることは有り得ないことと(×２)、右上角のクイーンを他の３つの
 * 角に写像させることができるので(×４)、このユニーク解が属するグループの要素数は必
 * ず８個(＝２×４)になります。
 * 
 *   次に、クイーンが右上角以外にある場合は少し複雑になりますが、考察を簡潔にする
 * ために次の事柄を確認します。
 *
 * TOTAL = (COUNT8 * 8) + (COUNT4 * 4) + (COUNT2 * 2);
 *   (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
 *    ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
 *    ジナルと同型になる。  
 *
 *    COUNT2 * 2
 * 
 *   (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナ
 *    ルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有
 *    り得る。 
 *
 *    COUNT4 * 4
 * 
 *   (3) (1) に該当するユニーク解が属するグループの要素数は、左右反転させたパターンを
 *       加えて２個しかありません。(2)に該当するユニーク解が属するグループの要素数は、
 *       180度回転させて同型になる場合は４個(左右反転×縦横回転)、そして180度回転させても
 *       オリジナルと異なる場合は８個になります。(左右反転×縦横回転×上下反転)
 * 
 *    COUNT8 * 8 
 *
 *   以上のことから、ひとつひとつのユニーク解が上のどの種類に該当するのかを調べる
 * ことにより全解数を計算で導き出すことができます。探索時間を短縮させてくれる枝刈
 * りを外す必要がなくなったというわけです。 
 * 
 *   UNIQUE  COUNT2      +  COUNT4      +  COUNT8
 *   TOTAL  (COUNT2 * 2) + (COUNT4 * 4) + (COUNT8 * 8)
 *
 * 　これらを実現すると、前回のNQueen3()よりも実行速度が遅くなります。
 * 　なぜなら、対称・反転・斜軸を反転するための処理が加わっているからです。
 * ですが、今回の処理を行うことによって、さらにNQueen5()では、処理スピードが飛
 * 躍的に高速化されます。そのためにも今回のアルゴリズム実装は必要なのです。
 *
  実行結果
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:02
16:     14772512         1846955      0 00:00:13
17:     95815104        11977939      0 00:01:29


  ９．ビットマップ＋枝刈りと最適化

  前章のコードは全ての解を求めた後に、ユニーク解以外の対称解を除去していた
  ある意味、「生成検査法（generate ＆ test）」と同じである
  問題の性質を分析し、バックトラッキング/前方検査法と同じように、無駄な探索を省略することを考える
  ユニーク解に対する左右対称解を予め削除するには、1行目のループのところで、
  右半分だけにクイーンを配置するようにすればよい
  Nが奇数の場合、クイーンを1行目中央に配置する解は無い。
  他の3辺のクィーンが中央に無い場合、その辺が上辺に来るよう回転し、場合により左右反転することで、
  最小値解とすることが可能だから、中央に配置したものしかユニーク解には成り得ない
  しかし、上辺とその他の辺の中央にクィーンは互いの効きになるので、配置することが出来ない


  1. １行目角にクイーンがある場合、とそうでない場合で処理を分ける
    １行目かどうかの条件判断はループ外に出してもよい
    処理時間的に有意な差はないので、分かりやすいコードを示した
  2.１行目角にクイーンがある場合、回転対称形チェックを省略することが出来る
    １行目角にクイーンがある場合、他の角にクイーンを配置することは不可
    鏡像についても、主対角線鏡像のみを判定すればよい
    ２行目、２列目を数値とみなし、２行目＜２列目という条件を課せばよい

  １行目角にクイーンが無い場合、クイーン位置より右位置の８対称位置にクイーンを置くことはできない
  置いた場合、回転・鏡像変換により得られる状態のユニーク判定値が明らかに大きくなる
    ☓☓・・・Ｑ☓☓
    ☓・・・／｜＼☓
    ｃ・・／・｜・rt
    ・・／・・｜・・
    ・／・・・｜・・
    lt・・・・｜・ａ
    ☓・・・・｜・☓
    ☓☓ｂ・・dn☓☓
    
  １行目位置が確定した時点で、配置可能位置を計算しておく（☓の位置）
  lt, dn, lt 位置は効きチェックで配置不可能となる
  回転対称チェックが必要となるのは、クイーンがａ, ｂ, ｃにある場合だけなので、
  90度、180度、270度回転した状態のユニーク判定値との比較を行うだけで済む


  実行結果
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:00
16:     14772512         1846955      0 00:00:02
17:     95815104        11977939      0 00:00:16


  １０．もっとビットマップ すごく速い！ 高橋謙一郎様（takaken版）の労作
  実行結果
 N:           Total          Unique days hh:mm:ss.--
 2:               0               0            0.00
 3:               0               0            0.00
 4:               0               0            0.00
 5:              10               2            0.00
 6:               4               1            0.00
 7:              40               6            0.00
 8:              92              12            0.00
 9:             352              46            0.00
10:             724              92            0.00
11:            2680             341            0.00
12:           14200            1787            0.00
13:           73712            9233            0.01
14:          365596           45752            0.04
15:         2279184          285053            0.26
16:        14772512         1846955            1.70
17:        95815104        11977939           11.79

  11.マルチスレッド（構造体）
  実行結果 
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:00
16:     14772512         1846955      0 00:00:02
17:     95815104        11977939      0 00:00:14


  12.マルチスレッド（pthread)
  実行結果 
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:00
16:     14772512         1846955      0 00:00:02
17:     95815104        11977939      0 00:00:14


  13.マルチスレッド(join）
  実行結果 
 N:        Total       Unique        dd:hh:mm:ss
 2:            0               0      0 00:00:00
 3:            0               0      0 00:00:00
 4:            2               1      0 00:00:00
 5:           10               2      0 00:00:00
 6:            4               1      0 00:00:00
 7:           40               6      0 00:00:00
 8:           92              12      0 00:00:00
 9:          352              46      0 00:00:00
10:          724              92      0 00:00:00
11:         2680             341      0 00:00:00
12:        14200            1787      0 00:00:00
13:        73712            9233      0 00:00:00
14:       365596           45752      0 00:00:00
15:      2279184          285053      0 00:00:00
16:     14772512         1846955      0 00:00:03
17:     95815104        11977939      0 00:00:19


  14．マルチスレッド(mutex) 
  mutexによるロックとロック解除の頻発がボトルネックとなり、
  並行処理のメリットが出ません。

  実行結果 
 N:           Total           Unique          hh:mm:ss
 2:               0                0        0000:00:00
 3:               0                0        0000:00:00
 4:               2                1        0000:00:00
 5:              10                2        0000:00:00
 6:               4                1        0000:00:00
 7:              40                6        0000:00:00
 8:              92               12        0000:00:00
 9:             352               46        0000:00:00
10:             724               92        0000:00:00
11:            2680              341        0000:00:00
12:           14200             1787        0000:00:00
13:           73712             9233        0000:00:00
14:          365596            45752        0000:00:00
15:         2279184           285053        0000:00:00
16:        14772512          1846955        0000:00:00
17:        95815104         11977939        0000:00:06


 15．マルチスレッド(アトミック対応) 
 mutex１つをロック・ロック解除で使い回すことでボトルネックが発生しました。
 また、mutexをスレッドの数だけ生成し、スレッド毎にロック/ロック解除を
 繰り返すことでオーバーヘッドは少なくなったものの、依然としてシングルスレッ
 ドよりも速度は遅くなることとなりました。
 高速化を実現するならばmutexで排他処理を行うよりも、アトミックに
 メモリアクセスする方が良さそうです。
 排他処理に必要な箇所はCOUNT++する箇所となります。
 具体的にはカウントする変数をスレッド毎の配列に格納し、
 COUNT2[BOUND1] COUNT4[BOUND1] COUNT8[BOUND1]で実装します。

 実行結果 
 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.02
15:         2279184           285053        0000:00:00.12
16:        14772512          1846955        0000:00:00.78
17:        95815104         11977939        0000:00:05.05


   16．マルチスレッド(アドレスとポインタ) 
  実行結果 
 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.62
17:        95815104         11977939        0000:00:04.08

  
 17．アドレスとポインタ(脱構造体)     NQueen17() N17: 00:03
  実行結果 
 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.02
15:         2279184           285053        0000:00:00.13
16:        14772512          1846955        0000:00:00.82
17:        95815104         11977939        0000:00:05.32

   
 <>18．アドレスとポインタ(脱配列)       NQueen18()
  実行結果 


  参考（Bash版 07_8NQueen.lua）
  13:           73712             9233                99
  14:          365596            45752               573
  15:         2279184           285053              3511

  参考（Lua版 07_8NQueen.lua）
  14:          365596            45752          00:00:00
  15:         2279184           285053          00:00:03
  16:        14772512          1846955          00:00:20

  参考（Java版 NQueen8.java マルチスレット）
  16:        14772512          1846955          00:00:00
  17:        95815104         11977939          00:00:04
  18:       666090624         83263591          00:00:34
  19:      4968057848        621012754          00:04:18
  20:     39029188884       4878666808          00:35:07
  21:    314666222712      39333324973          04:41:36
  22:   2691008701644     336376244042          39:14:59
 *
*/
/*
1,構造体のみ追加
void backTrack2(int y,int left,int down,int right,struct local *l,int *si,
     int *bo,int *bo2,int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.15
16:        14772512          1846955        0000:00:00.99
17:        95815104         11977939        0000:00:06.12
2,SIZEEを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *bo,int *bo2,int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.16
16:        14772512          1846955        0000:00:00.93
17:        95815104         11977939        0000:00:05.74
18:       666090624         83263591        0000:00:39.43
3,BOUND1を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *bo2,int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.14
16:        14772512          1846955        0000:00:00.88
17:        95815104         11977939        0000:00:05.55
18:       666090624         83263591        0000:00:38.07
4,BOUND2を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.13
16:        14772512          1846955        0000:00:00.80
17:        95815104         11977939        0000:00:05.23
18:       666090624         83263591        0000:00:35.71
5,MASKを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.15
16:        14772512          1846955        0000:00:00.79
17:        95815104         11977939        0000:00:05.10
18:       666090624         83263591        0000:00:34.74
6,SIDEMASKを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.12
16:        14772512          1846955        0000:00:00.82
17:        95815104         11977939        0000:00:05.10
18:       666090624         83263591        0000:00:35.18
7,LASTMASKを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.11
16:        14772512          1846955        0000:00:00.74
17:        95815104         11977939        0000:00:04.71
18:       666090624         83263591        0000:00:32.08
8,TOPBITを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.14
16:        14772512          1846955        0000:00:00.70
17:        95815104         11977939        0000:00:04.50
18:       666090624         83263591        0000:00:30.82
9,ENDBITを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.65
17:        95815104         11977939        0000:00:04.31
18:       666090624         83263591        0000:00:29.26
10,aBoardを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.58
17:        95815104         11977939        0000:00:03.69
18:       666090624         83263591        0000:00:24.89
10,COUNT2を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     long *c4,long *c8){
15:         2279184           285053        0000:00:00.11
16:        14772512          1846955        0000:00:00.56
17:        95815104         11977939        0000:00:03.68
18:       666090624         83263591        0000:00:24.65
11,COUNT4を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     long *c8){
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.56
17:        95815104         11977939        0000:00:03.65
18:       666090624         83263591        0000:00:24.94
12,COUNT8を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     ){
15:         2279184           285053        0000:00:00.11
16:        14772512          1846955        0000:00:00.65
17:        95815104         11977939        0000:00:04.21
18:       666090624         83263591        0000:00:28.76
13,COUNT2,COUNT4,COUNT8を外出しにする。SIDEMASKを変数に入れて使う
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.57
17:        95815104         11977939        0000:00:03.66
18:       666090624         83263591        0000:00:24.70
#


 <>20．アドレスとポインタ(考察５)       NQueen20()
 配列カウンターはアクセスが多いので構造体から出して
 グローバル変数に。さらにスレッド対応にするため、
 カウンター配列とした。

long C2[MAX];
long C4[MAX];
long C8[MAX];

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.58
17:        95815104         11977939        0000:00:03.82


 <>21．アドレスとポインタ(考察６) 

void symmetryOps_bm(void *args,long *C2,long *C4,long *C8);
  ↓
void symmetryOps_bm(local *l,long *C2,long *C4,long *C8);

  こうすることによって以下の宣言が不要となった
  local *l=(local *)args;

対象関数は以下の通り
void symmetryOps_bm(local *l,long *C2,long *C4,long *C8);
void backTrack2(int y,int left,int down,int right,local *l,long *C2,long *C4,long *C8);
void backTrack1(int y,int left,int down,int right,local *l,long *C8);

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.58
17:        95815104         11977939        0000:00:03.80



 <>22．アドレスとポインタ(考察７)
 比較的どの関数でもアクセスの多い siE変数はG.siEという
 ふうに構造体に格納されているが、関数の先頭で変数に代入し、
 メソッド内での構造体へのアクセス頻度を減らす。

  int _siE=G.siE;

  //90度回転
  if(l->aB[l->B2]==1){ own=1; ptn=2;
    //while(own<=G.siE){ bit=1; you=G.siE;
    while(own<=_siE){ bit=1; you=_siE;


  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.59
17:        95815104         11977939        0000:00:03.85


 <>23．アドレスとポインタ(考察８) 
	SIDEMASKをCOUNT同様にグローバル変数に外だし
	不要なループを除去
　不明な最大値を見直し

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.57
17:        95815104         11977939        0000:00:03.73

 <>24．アドレスとポインタ(完結) 
  カウンター以外の変数を外だししてみたが、カウンター外だし
　ほどの効果を得ることはできなかった。
　なので、ソースの可読性を含めカウンター以外は構造体に含める。
  NQ24はNQ21のソースを拡張して展開することとした。
  さらに外だしすると硬貨があるように見えた配列カウンターも
  構造体の中に含める方がよりNが大きくなると最適化されること
  がわかったので構造体に戻した。

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.57
17:        95815104         11977939        0000:00:03.73


 <>25．最適化 									        NQueen25() N17=03:70
=== 1 ===
 G構造体に格納していた int si int siE int lTotal int lUniqueを
 グローバル変数に置き換えました。ちょっと速くなりました。

=== 2 ===
 L構造体に格納していたC2/C4/C8カウンターの置き場所を変えて比較

1.
// long C2[MAX]; //グローバル環境に置くと N=17: 08.04
// long C4[MAX];
// long C8[MAX];

2.
//  long C2; // 構造体の中の配列をなくすとN=17: 05.24
//  long C4;
//  long C8;

3. 構造体の中でポインタアクセスにしてみる // N=17 : 05.87
   さらにcallocにより、宣言時に適切なメモリサイズを割り当てる
// int *ab; 
//  l[B1].aB=calloc(G.si,sizeof(int));

4.
  long C2[MAX];//構造体の中の配列を活かすと   N=17: 04.33
  long C4[MAX];
  long C8[MAX];

 よって、カウンターはL構造体の中に配置し、スレッド毎にカウンター
を管理する配列で構築しました。
同様に、カウントする箇所は以下のように書き換えました。

			l->C4[l->B1]++;

これによりちょっと速くなりました。

=== 3 ===
　symmetryOps_bm()/trackBack1()/trackBack2()のメソッドないで宣言されている
ローカル変数を撲滅しました。
　symmetryOps_bm()の中では以下の通りです。

  int own,ptn,you,bit;

こちらは全てL構造体でもち、
　l->own などでアクセスするようにしました。構造体に配置すると遅くなる
　という本をよく見ますが、激しく呼び出されるメソッドで変数が都度生成される
　コストと比べると計測から見れば、構造体で持った方が速いと言うことがわかりました。
これによりちょっと速くなりました。

=== 4 ===
 backTrack1()/backTrack2()のbm以外の変数はbitだけです。こちらは簡単に構造体に
　格納して実装することができました。問題はbm(bitmap)です。
　こちらは、再帰で変化する変数で、スレッド毎に値も変わることから値渡しである
　必要があります。よって関数の引数の中に格納することとしました。

void backTrack2(int y,int left,int down,int right,int bm,local *l){
void backTrack1(int y,int left,int down,int right,int bm,local *l){
これによりちょっと速くなりました。

=== 5 ===
pthreadや構造体 lは　#defineで宣言されるMAX=27を使って初期化していました。
si siEをグローバル変数としたことで、これらもNの値で初期化することとしました。

void *NQueenThread(){
  //pthread_t pt[G.si];//スレッド childThread
  pthread_t pt[si];//スレッド childThread
  //local l[MAX];//構造体 local型 
  local l[si];//構造体 local型 

=== 5 ===
	CPU affinity
	論理CPUにスレッドを割り当てる

#if _GNU_SOURCE
#define _GNU_SOURCE
#include <sched.h> 
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define handle_error_en(en, msg) do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)
#endif


# run ソース部分：
#ifdef _GNU_SOURCE
  pthread_t thread = pthread_self();
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(l->B1, &cpuset);
  int s=pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
  if (s != 0){ handle_error_en(s, "pthread_setaffinity_np"); }
  s=pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
  if (s != 0){ handle_error_en(s, "pthread_getaffinity_np"); }
  //printf("pid:%10d#l->B1:%2d#cpuset:%d\n",thread,l->B1,&cpuset);
#endif

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0        0000:00:00.00
 3:               0                0        0000:00:00.00
 4:               2                1        0000:00:00.00
 5:              10                2        0000:00:00.00
 6:               4                1        0000:00:00.00
 7:              40                6        0000:00:00.00
 8:              92               12        0000:00:00.00
 9:             352               46        0000:00:00.00
10:             724               92        0000:00:00.00
11:            2680              341        0000:00:00.00
12:           14200             1787        0000:00:00.00
13:           73712             9233        0000:00:00.00
14:          365596            45752        0000:00:00.01
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.58
17:        95815104         11977939        0000:00:03.52

  参考（Bash版 07_8NQueen.lua）
  13:           73712             9233                99
  14:          365596            45752               573
  15:         2279184           285053              3511

  参考（Lua版 07_8NQueen.lua）
  14:          365596            45752          00:00:00
  15:         2279184           285053          00:00:03
  16:        14772512          1846955          00:00:20

  参考（Java版 NQueen8.java マルチスレット）
  16:        14772512          1846955          00:00:00
  17:        95815104         11977939          00:00:04
  18:       666090624         83263591          00:00:34
  19:      4968057848        621012754          00:04:18
  20:     39029188884       4878666808          00:35:07
  21:    314666222712      39333324973          04:41:36
  22:   2691008701644     336376244042          39:14:59
 *
*/

#define _GNU_SOURCE
#include <sched.h> 
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define handle_error_en(en, msg) do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX 27

int si;  //si siE lTotal lUnique をグローバルに置くと N=17: 04.26
int siE;
long lTotal;
long lUnique;

/** スレッドローカル構造体 */
typedef struct{
	int bit;
  int own;
	int ptn;
	int you;
  int B1;
  int B2;
  int TB;
  int EB;
  int msk;
  int SM;
  int LM;
  int aB[MAX]; 
	// int *ab; // N=17 : 05.87
  //  l[B1].aB=calloc(G.si,sizeof(int));
  long C2[MAX];//構造体の中の配列を活かすと   N=17: 04.33
  long C4[MAX];
  long C8[MAX];
//  long C2; // 構造体の中の配列をなくすとN=17: 05.24
//  long C4;
//  long C8;
}local ;

// long C2[MAX]; //グローバル環境に置くと N=17: 08.04
// long C4[MAX];
// long C8[MAX];

//グローバル構造体
//typedef struct {
//  int si;
//  int siE;
//  long lTotal;
//  long lUnique;
//}GCLASS, *GClass;
//GCLASS G; 


void symmetryOps_bm(local *l);
void backTrack2(int y,int left,int down,int right,int bm,local *l);
void backTrack1(int y,int left,int down,int right,int bm,local *l);
void *run(void *args);
void *NQueenThread();
void NQueen();

void symmetryOps_bm(local *l){
  //int own,ptn,you,bit;
  l->own=l->ptn=l->you=l->bit=0;
  //90度回転
  if(l->aB[l->B2]==1){ l->own=1; l->ptn=2;
    //while(l->own<=G.siE){ l->bit=1; l->you=G.siE;
    while(l->own<=siE){ l->bit=1; l->you=siE;
      while((l->aB[l->you]!=l->ptn)&&(l->aB[l->own]>=l->bit)){ l->bit<<=1; l->you--; }
      if(l->aB[l->own]>l->bit){ return; } if(l->aB[l->own]<l->bit){ break; }
      l->own++; l->ptn<<=1;
    }
    /** 90度回転して同型なら180度/270度回転も同型である */
    //if(l->own>G.siE){ 
    if(l->own>siE){ 
			//C2[l->B1]++;
			l->C2[l->B1]++;
      return; }
  }
  //180度回転
  //if(l->aB[G.siE]==l->EB){ l->own=1; l->you=G.siE-1;
  if(l->aB[siE]==l->EB){ l->own=1; l->you=siE-1;
    //while(l->own<=G.siE){ l->bit=1; l->ptn=l->TB;
    while(l->own<=siE){ l->bit=1; l->ptn=l->TB;
      while((l->aB[l->you]!=l->ptn)&&(l->aB[l->own]>=l->bit)){ l->bit<<=1; l->ptn>>=1; }
      if(l->aB[l->own]>l->bit){ return; } if(l->aB[l->own]<l->bit){ break; }
      l->own++; l->you--;
    }
    /** 90度回転が同型でなくても180度回転が同型である事もある */
    //if(l->own>G.siE){ 
    if(l->own>siE){ 
			//C4[l->B1]++;
			l->C4[l->B1]++;
      return; }
  }
  //270度回転
  if(l->aB[l->B1]==l->TB){ l->own=1; l->ptn=l->TB>>1;
    //while(l->own<=G.siE){ l->bit=1; l->you=0;
    while(l->own<=siE){ l->bit=1; l->you=0;
      while((l->aB[l->you]!=l->ptn)&&(l->aB[l->own]>=l->bit)){ l->bit<<=1; l->you++; }
      if(l->aB[l->own]>l->bit){ return; } if(l->aB[l->own]<l->bit){ break; }
      l->own++; l->ptn>>=1;
    }
  }
  // G.C8[l->B1]++;
  //(*C8)++;
	//C8[l->B1]++;
	l->C8[l->B1]++;
}

void backTrack2(int y,int left,int down,int right,int bm,local *l){
  //配置可能フィールド
  //int bit=0;
  //int bm=l->msk&~(left|down|right); 
  bm=l->msk&~(left|down|right); 
  l->bit=0;
  //if(y==G.siE){
  if(y==siE){
    if(bm>0 && (bm&l->LM)==0){ //【枝刈り】最下段枝刈り
      l->aB[y]=bm;
      //対称解除法
      //symmetryOps_bm(l,C2,C4,C8);//対称解除法
      symmetryOps_bm(l);
    }
  }else{
    //【枝刈り】上部サイド枝刈り
    if(y<l->B1){             
      bm&=~l->SM; 
    //【枝刈り】下部サイド枝刈り
    }else if(y==l->B2) {     
      if((down&l->SM)==0){ return; }
      if((down&l->SM)!=l->SM){ bm&=l->SM; }
    }
    while(bm>0) {
      //最も下位の１ビットを抽出
      //bm^=l->aB[y]=bit=-bm&bm;
      bm^=l->aB[y]=l->bit=-bm&bm;
      //backTrack2(y+1,(left|bit)<<1,down|bit,(right|bit)>>1,l);
      backTrack2(y+1,(left|l->bit)<<1,down|l->bit,(right|l->bit)>>1,bm,l);
    }
  }
}
void backTrack1(int y,int left,int down,int right,int bm,local *l){
  //int bit;
  //int bm=l->msk&~(left|down|right); 
  bm=l->msk&~(left|down|right); 
  l->bit=0;
  //if(y==G.siE) {
  if(y==siE) {
    if(bm>0){
      l->aB[y]=bm;
      //【枝刈り】１行目角にクイーンがある場合回転対称チェックを省略
			//C8[l->B1]++;
			l->C8[l->B1]++;
    }
  }else{
    if(y<l->B1) {   
      //【枝刈り】鏡像についても主対角線鏡像のみを判定すればよい
      //bm|=2; 
      //bm^=2;
      bm&=~2; 
    }
    while(bm>0) {
      //最も下位の１ビットを抽出
      //bm^=l->aB[y]=bit=-bm&bm;
      bm^=l->aB[y]=l->bit=-bm&bm;
      //backTrack1(y+1,(left|bit)<<1,down|bit,(right|bit)>>1,l);
      backTrack1(y+1,(left|l->bit)<<1,down|l->bit,(right|l->bit)>>1,bm,l);
    }
  } 
}
void *run(void *args){
  local *l=(local *)args;
  //int bit ;
  //l->bit=0 ; l->aB[0]=1; l->msk=(1<<G.si)-1; l->TB=1<<G.siE;

#if deffine _GNU_SOURCE
//#ifdef _GNU_SOURCE
  pthread_t thread = pthread_self();
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(l->B1, &cpuset);
  int s=pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
  if (s != 0){ handle_error_en(s, "pthread_setaffinity_np"); }
  s=pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
  if (s != 0){ handle_error_en(s, "pthread_getaffinity_np"); }
  printf("pid:%10ld#l->B1:%2d#cpuset:%d\n",thread,l->B1,&cpuset);
#endif

  l->bit=0 ; l->aB[0]=1; l->msk=(1<<si)-1; l->TB=1<<siE;
  //if(l->B1>1 && l->B1<G.siE) { // 最上段のクイーンが角にある場合の探索
  if(l->B1>1 && l->B1<siE) { // 最上段のクイーンが角にある場合の探索
    l->aB[1]=l->bit=(1<<l->B1);// 角にクイーンを配置 
    backTrack1(2,(2|l->bit)<<1,(1|l->bit),(l->bit>>1),0,l);//２行目から探索
  }
  l->EB=(l->TB>>l->B1);
  l->SM=l->LM=(l->TB|1);
  //if(l->B1>0&&l->B2<G.siE&&l->B1<l->B2){ // 最上段行のクイーンが角以外にある場合の探索 
  if(l->B1>0&&l->B2<siE&&l->B1<l->B2){ // 最上段行のクイーンが角以外にある場合の探索 
    for(int i=1; i<l->B1; i++){
      l->LM=l->LM|l->LM>>1|l->LM<<1;
    }
    l->aB[0]=l->bit=(1<<l->B1);
    backTrack2(1,l->bit<<1,l->bit,l->bit>>1,0,l);
    //l->EB>>=G.si;
    l->EB>>=si;
  }
  return 0;
}
void *NQueenThread(){
  //pthread_t pt[G.si];//スレッド childThread
  pthread_t pt[si];//スレッド childThread
  //local l[MAX];//構造体 local型 
  local l[si];//構造体 local型 
  //for(int B1=G.siE,B2=0;B2<G.siE;B1--,B2++){// B1から順にスレッドを生成しながら処理を分担する 
  for(int B1=siE,B2=0;B2<siE;B1--,B2++){// B1から順にスレッドを生成しながら処理を分担する 
    l[B1].B1=B1; l[B1].B2=B2; //B1 と B2を初期化
    //for(int j=0;j<G.siE;j++){ l[l->B1].aB[j]=j; } // aB[]の初期化
    for(int j=0;j<siE;j++){ l[l->B1].aB[j]=j; } // aB[]の初期化
	  l[B1].C2[B1]=l[B1].C4[B1]=l[B1].C8[B1]=0;	//カウンターの初期化
    //int iFbRet=pthread_create(&pt[B1],NULL,&run,&l[B1]);// チルドスレッドの生成
    int iFbRet=pthread_create(&pt[B1],NULL,&run,(void*)&l[B1]);// チルドスレッドの生成
    if(iFbRet>0){
      printf("[mainThread] pthread_create #%d: %d\n", l[B1].B1, iFbRet);
    }
  }
  //for(int B1=G.siE,B2=0;B2<G.siE;B1--,B2++){ 
  for(int B1=siE,B2=0;B2<siE;B1--,B2++){ 
    pthread_join(pt[B1],NULL); 
  }
  //for(int B1=G.siE,B2=0;B2<G.siE;B1--,B2++){//スレッド毎のカウンターを合計
  for(int B1=siE,B2=0;B2<siE;B1--,B2++){//スレッド毎のカウンターを合計
    //G.lTotal+=l[B1].C2[B1]*2+l[B1].C4[B1]*4+l[B1].C8[B1]*8;
    lTotal+=l[B1].C2[B1]*2+l[B1].C4[B1]*4+l[B1].C8[B1]*8;
    //G.lUnique+=l[B1].C2[B1]+l[B1].C4[B1]+l[B1].C8[B1]; 
    lUnique+=l[B1].C2[B1]+l[B1].C4[B1]+l[B1].C8[B1]; 
  }
  return 0;
}
void NQueen(){
  pthread_t pth;//スレッド変数
  int iFbRet = pthread_create(&pth, NULL, &NQueenThread, NULL);// メインスレッドの生成
  if(iFbRet>0){
    printf("[main] pthread_create: %d\n", iFbRet); //エラー出力デバッグ用
  }
  pthread_join(pth, NULL); //スレッドの終了を待つ
}
int main(void){
  int min=2;
  struct timeval t0;
  struct timeval t1;
  printf("%s\n"," N:        Total       Unique        hh:mm:ss.ms");
  for(int i=min;i<=MAX;i++){
    //G.si=i; G.siE=i-1; 
    si=i; siE=i-1; 
    //G.lTotal=G.lUnique=0;
    lTotal=lUnique=0;
    gettimeofday(&t0, NULL);
    NQueen();
    gettimeofday(&t1, NULL);
    int ss;int ms;
    if (t1.tv_usec<t0.tv_usec) {
      ss=(t1.tv_sec-t0.tv_sec-1)%86400; 
      ms=(1000000+t1.tv_usec-t0.tv_usec+500)/10000; 
    } else { 
      ss=(t1.tv_sec-t0.tv_sec)%86400; 
      ms=(t1.tv_usec-t0.tv_usec+500)/10000; 
    }
    int hh=ss/3600; 
    int mm=(ss-hh*3600)/60; 
    ss%=60;
    //printf("%2d:%16ld%17ld%12.4d:%02d:%02d.%02d\n", i,G.lTotal,G.lUnique,hh,mm,ss,ms); 
    printf("%2d:%16ld%17ld%12.4d:%02d:%02d.%02d\n", i,lTotal,lUnique,hh,mm,ss,ms); 
  } 
	return 0;
}
