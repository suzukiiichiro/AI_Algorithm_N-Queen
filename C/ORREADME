#お姉さんロボ
#README
#1,おねえさんが利用したであろう自作の深さ優先探索(DFS)プログラム
#Node構造体から経路を辿って数え上げるだけの単純なプログラム
#./or1 7
#
#2,simpath algorithm
#https://github.com/masakazu-ishihata/simpath
#ざっくりアルゴリズムのアイディアを述べるのであれば、
#
#「共通パスをできるだけまとめ上げる」
#
#です。実際に３×３の s-t path 問題を解いてみると分かると思いますが、いくつかの s-t path は共通の部分パスを持ちます。
#この共通部分を発見するために simpath algorithm では「mate 配列」と「フロンティア」というアイディアを導入します。
#
#mate 配列とは（作りかけの）パスの"状態"を表します。 そしてこの"状態"とはとても素敵で、 「mate 配列の値が一致すれば、その後の展開も一致する」 という性質を持ちます。 つまりパスの展開中に過去と同じ mate 配列の値が現れれば、そこはもはや展開する必要がないのです！ このように mate 配列の値を記憶しておくことでパスの再展開を回避でき、効率的に s-t path を数えられるのです。
#
#フロンティアとは mate 配列のうち、今気にするべき領域です。 mate 配列は現在の展開の状態を表しますが、探索をしていくうちに mate 配列はもはや参考にする必要がのない部分を持ちます。 フロンティアとは今現在、気にするべき領域であり、逆にフロンティアの状態を表しているのが mate 配列といってもいいです。
#
#このフロンティアと mate 配列を利用することで効率よく s-t path を数えられるのです。
#
#time ruby simpath.rb -n 8
