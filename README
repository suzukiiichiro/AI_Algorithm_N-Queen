/**
  Cで学ぶアルゴリズムとデータ構造  
  ステップバイステップでＮ−クイーン問題を最適化
  一般社団法人  共同通信社  情報技術局  鈴木  維一郎(suzuki.iichiro@kyodonews.jp)
  
   １．ブルートフォース（力まかせ探索） NQueen01() 
   ２．配置フラグ（制約テスト高速化）   NQueen02() 
   ３．バックトラック                   NQueen03() N17= 12:29.59
   ４．対称解除法(回転と斜軸）          NQueen04() N17=  2:40.86 
   ５．枝刈りと最適化                   NQueen05() N17=  2:15:80 
   ６．ビットマップ                     NQueen06() N17=  1:40.79
   ７．ビットマップ+対称解除法          NQueen07() N17=  3:06.11
   ８．ビットマップ+クイーンの場所で分岐NQueen08() N17=  2:15.80
   ９．ビットマップ+枝刈りと最適化      NQueen09() N17=    15.30
   10．もっとビットマップ(takaken版)    NQueen10() N17=    15.76
   11．マルチスレッド(構造体)           NQueen11() N17=    11.79
   12．マルチスレッド(pthread)          NQueen12() N17=    14.53
   13．マルチスレッド(mutex)            NQueen13() N17=    14.12
   14．マルチスレッド(mutexattr)        NQueen14() N17=    05.70
   15．マルチスレッド(脱mutex COUNT強化)NQueen15() N17=    05.66
   15t.もっとマルチスレッド(takaken版) NQueen15_t()N17=    12.59
   16．アドレスとポインタ(考察１)       NQueen16() N17=    06.11
   17．アドレスとポインタ(考察２)       NQueen17() N17=    06.62
   18．アドレスとポインタ(考察３)       NQueen18() N17=    06.67
   19．アドレスとポインタ(考察４)       NQueen19() N17=    06.28
   20．アドレスとポインタ(考察５)       NQueen20() N17=    07.37
   21．アドレスとポインタ(考察６)       NQueen21() N17=    07.57
   22．アドレスとポインタ(考察７)       NQueen22() N17=    07.55
   23．アドレスとポインタ(考察８)       NQueen23() N17=    08.31
   24．アドレスとポインタ(完結)         NQueen24() N17=    04.19 N18=00:32.44
   25．最適化                           NQueen25() N17=    04.47 N18=00:35.44
   26．マルチスレッド再び               NQueen26() N17=    04.62 N18=00:36.79
   27．もっとマルチスレッド(NxN)        NQueen27() N17=    03.23 N18=00:27.21 大暴走
   28．さらにマルチスレッド(NxNxN)      NQueen28() N17=    03.60 N18=00:28.16 大暴走
   29．マルチスレッドもっと最適化       NQueen29() N17=    03.41 N18=00:28.60 大暴走
   30．マルチスレッドもっと最適化４段目 NQueen30() N17=    04.53 N18=00:31.91
   31. マルチスレッドもっと最適化５段目 NQueen31() N17=    12.55 N18=00:46.62
   32. マルチスレッド  ハイブリッド版   NQueen32() N17=    03.72 N18=00:29.43
   33. マルチスレッド 脱malloc          NQueen33() N17=          N18=



 # Jav/C/Lua/Bash版
 # https://github.com/suzukiiichiro/N-Queen


実行結果 07_29NQueen.c 
実行方法:   $ make nq29 && ./07_29NQueen

 --------------------------------------- 共同通信社   電通大(N24） QJH(GPU)版  高橋謙一郎 Somers版(N22)
 N:          Total       Unique          dd:hh:mm:ss                            
 2:                 0                0   00:00:00:00                            
 3:                 0                0   00:00:00:00                            
 4:                 2                1   00:00:00:00                            
 5:                10                2   00:00:00:00                            
 6:                 4                1   00:00:00:00                            
 7:                40                6   00:00:00:00                            
 8:                92               12   00:00:00:00                            
 9:               352               46   00:00:00:00                            
10:               724               92   00:00:00:00                            
11:              2680              341   00:00:00:00                            
12:             14200             1787   00:00:00:00                            
13:             73712             9233   00:00:00:00                            
14:            365596            45752   00:00:00:00                                                
15:           2279184           285053   00:00:00:00                 00:00:00    00:00:00  00:00:04
16:          14772512          1846955   00:00:00:00                 00:00:00    00:00:04  00:00:23
17:          95815104         11977939   00:00:00:03                 00:00:07    00:00:31  00:02:38
18:         666090624         83263591   00:00:00:30  00:00:00:12    00:00:25    00:03:48  00:19:26
19:        4968057848        621012754   00:00:05:08  00:00:00:42    00:03:17    00:29:22  02:31:24
20:       39029188884       4878666808   00:00:40:31  00:00:04:46    00:24:07    03:54:10  20:35:06
21:      314666222712      39333324973   00:05:38:49  00:00:41:37    03:05:28 01:09:17:19                      
22      2691008701644     336376244042   02:02:03:49  00:05:50:02 01:03:08:20                                       
23     24233937684440    3029242658210                02:08:52:30                         
24    227514171973736   28439272956934                21:18:10:31                         
25   2207893435808352  275986683743434
26  22317699616364044 2789712466510289
27 234907967154122528











 
*************************
はじめに
*************************

幸運にもこのページを参照することができたN-Queen(Nクイーン）エンジニアは少数だろう。
Google検索またはGit検索でたどり着いたのだとは思うが、確率は奇跡に近い。
エンジニアにしてこのページを参照できた奇跡ついでにもう少しだけ読み進めて欲しい。
具体的には以下のリンクにわかりやすく書いてある。

  エイト・クイーン問題
  https://ja.wikipedia.org/wiki/エイト・クイーン
 
エイト・クイーンは、1848年から存在し、ガウスなど著名な科学者が研究した工学研究の
頂点となる研究である。名前の通り８つのクイーンの解を求めるというパズルであり、
Nクイーンは、エイトクイーンの拡張版で、Nの値は８、９、１０，１１，１２･･･と言った風
に増え続け、そのNの値であるボードの解を求めるものである。


*************************
歴史的未解決問題に懸賞金
*************************

歴史あるチェスのパズル問題が現代数学における未解決問題の解明につながる可能性
http://gigazine.net/news/20170905-million-dollar-chess-problem/

1000年を超える歴史を持つボードゲーム「チェス」には単なるゲームの勝敗ではなく、
そのルールに即したさまざまなパズルの課題「チェス・プロブレム」が存在しています。
エイト・クイーンはチェスの駒のうち、8個のクイーンだけを使うパズルなのですが、そ
の規模を大きく拡大して行くと、現代数学における未解決問題であり、1億円の賞金がか
かる「P対NP問題」の解明につながるものと考えられています。

2017 | “Simple” chess puzzle holds key to $1m prize | University of St Andrews
https://www.st-andrews.ac.uk/news/archive/2017/title,1539813,en.php

Can You Solve the Million-Dollar, Unsolvable Chess Problem? - Atlas Obscura
http://www.atlasobscura.com/articles/queens-puzzle-chess-problem-solution-software

「エイト・クイーン」は1848年にチェスプレイヤーのマックス・ベッツェルによって提
案されたパズル。8×8マスのチェス盤の上に、縦横と斜め方向にどこまででも進めるとい
う駒・クイーンを8個並べるというものなのですが、その際には「どの駒も他の駒に取ら
れるような位置においてはいけない」というルールが設定されています。このルールに
従った場合にいくつの正解が存在するのか、長らくの間にわたって謎とされていたので
すが、考案から100年以上が経過した1874年にGuntherが行列式を用いて解く方法を提案
し、イギリスのグレイシャー(Glaisher)によって全解(基本解)が12個であることを確認
しています。

この問題は、チェス盤の一辺のマスの数とクイーンの数を同一にしたn-クイーン問題と
も呼ばれており、nの数が増えるに連れて飛躍的にその解数が増大することが知られてい
ます。記事作成時点で全ての解が判明しているのは、2009年にドレスデン工科大学で計
算された「26-クイーン」で、その基本解は2789兆7124億6651万289個、転回形などのバ
リエーション解を含めると、その数は2京2317兆6996億1636万4044個にもなることがわかっ
ています。

セント・アンドルーズ大学のコンピューターサイエンティストであるIan Gent博士らに
よる研究チームは、この「n-クイーン問題」から派生する「n-クイーン穴埋め問題」
(n-Queens Completion)パズルの複雑性に関する(PDF
http://jair.org/media/5512/live-5512-10126-jair.pdf)論文を作成しています。n-ク
イーン穴埋め問題は、チェス盤の上にあらかじめいくつかのクイーンの駒を並べておい
た状態で、残りのクイーンを全て埋めるというパズル問題です。

基本的にこの問題を解決するためにはバックトラック法と呼ばれる、いわば「総当たり
法」が用いられますが、全ての選択肢を試すためには膨大な時間が必要とされ、しかも
マスとクイーンの数が多くなるとその時間は指数関数的に一気に増加します。Gent氏に
よると、この「n-クイーン穴埋め問題」を素早く解決できるコンピューターやアルゴリ
ズムの開発が進むことで、我々が日々抱えている問題を解決する技術の進化が期待でき
るとのこと。先述のように、現代の科学でも解決できているn-クイーン問題は26×26マス
の「26-クイーン」にとどまっており、穴埋め問題であってもそこから先へと進むために
は、現在はまだ存在していない新しい技術を開発することが必須となってきます。

この問題は、2000年にアメリカのクレイ数学研究所が100万ドル(約1億1000万円)の賞金
とともに設定したミレニアム懸賞問題の一つに数えられる「P対NP問題」の証明につなが
るものとされています。これは、「答えを見つけるのは難しいかもしれないが、答えが
あっているかどうかは素早くチェックできる問題」のことをNP問題、「簡単に素早く解
ける問題」のことをP問題とした時に、「素早く解けるP問題はすべて答えを素早く確認
できるNP問題である」ことは証明されているが、その逆、つまり「答えを素早く確認で
きるNP問題はすべて、素早く解けるか？」という問題を証明するというもの。 これを解
くためには膨大な量の計算を素早く行うことが必要になり、現代のコンピューター技術
でも解決までには数万年の時間が必要になると考えられています。


*************************
参考リンクなど
*************************


GooleなどWebを探索すると無数のページがあることがわかる。その中でも充実したサイトを
紹介したい。おおよそ以下のサイトをかみしめて読み解けば情報は９０％網羅されている。

N-Queens 問題(Nobuhide Tsudaさん)
*************************
  はじめに
  力まかせ探索（Brute-force search）
  バックトラッキング
  制約テスト高速化（配置フラグ）
  ビット演算（ビットマップ）による高速化
  対称解除去
  枝刈りによる高速化
  http://vivi.dyndns.org/tech/puzzle/NQueen.html

Puzzle DE Programming(M.Hiroiさん）
*************************
  バックトラックとビット演算による高速化
  http://www.geocities.jp/m_hiroi/puzzle/nqueens.html

takakenさん（高橋謙一郎さん）のページ
*************************
  Ｎクイーン問題（解の個数を求める）
    ビット処理を用いた基本形
    ビット処理を用いたプログラムの仕組み
    ユニーク解の判定方法
    ユニーク解の個数を求める
    ユニーク解から全解への展開
    ソースプログラムと実行結果
  http://www.ic-net.or.jp/home/takaken/nt/queen/index.html

の、みなさんが掲示板で議論している模様(貴重ですね）
http://www2.ic-net.or.jp/~takaken/auto/guest/bbs62.html

ptimal Queens
*************************
英語だが、上記の全てがJavaで書かれていて群を抜いている
http://penguin.ewu.edu/~trolfe/Queens/OptQueen.html

その他のリンク
https://rosettacode.org/wiki/N-queens_problem
http://www.cc.kyoto-su.ac.jp/~yamada/ap/backtrack.html
http://yucchi.jp/java/java_tip/n_queens_problem/n_queens_problem.html
http://www.shido.info/py/queen_py3.html
http://toraneko75.sakura.ne.jp/wp/?p=223
http://yoshiiz.blog129.fc2.com/blog-entry-380.html
http://nw.tsuda.ac.jp/class/algoB/c6.html
http://www.kawa.net/works/js/8queens/nqueens.html
http://www.yasugi.ai.kyutech.ac.jp/2012/4/nq.html
http://www.neuro.sfc.keio.ac.jp/~masato/jv/nqueen/MPneuron.java
http://fujimura2.fiw-web.net/java/lang/page-20-3.html
https://github.com/pankajmore/DPP/blob/master/EPI/src/puzzles/NQueens.java
http://www.kanadas.com/ccm/queens-sort/index-j.html
http://chiiji.s10.xrea.com/nn/nqueen/nqueenn.shtml
http://www.neuro.sfc.keio.ac.jp/~masato/jv/nqueen/nqueenDemo.htm


ここからは参考情報のメモとして

N=22発見 JeffSomers
  ビットマップを N-Queens に最初に応用したのは Jeff Somers 氏のようだ。 
  参照：The N Queens Problem
  http://www.jsomers.com/nqueen_demo/nqueens.html(リンク切れのようだ）

N=24発見 電気通信大学
  2004年、電気通信大学の研究グループが、処理を並列化し
  N=24 の解の個数を世界で初めて発見。 
  http://www.arch.cs.titech.ac.jp/~kise/nq/

  プレスリリース
  http://www.arch.cs.titech.ac.jp/~kise/nq/press-2004-10-05.txt

  電通大が「N-queens」問題の世界記録達成
  http://www.itmedia.co.jp/news/articles/0410/06/news079.html

  University of North Texas
  http://larc.unt.edu/ian/24queens/

  NQueens問題
  ＱＪＨの基本構想は、”部分解から全体解を構成するというアプローチ”（部分解合成法：Ｐａｒts Assembly Approach)です。
  http://deepgreen.game.coocan.jp/NQueens/nqueen_index.htm

  N Queens World records
  http://www.nqueens.de/sub/WorldRecord.en.html

  N=21-23 computed by Sylvain PION (Sylvain.Pion(AT)sophia.inria.fr) and Joel-Yann FOURRE (Joel-Yann.Fourre(AT)ens.fr).

  N=24 from Kenji KISE (kis(AT)is.uec.ac.jp), Sep 01 2004

  N=25 from Objectweb ProActive INRIA Team (proactive(AT)objectweb.org), Jun 11 2005 [Communicated by Alexandre Di Costanzo (Alexandre.Di_Costanzo(AT)sophia.inria.fr)]. This calculation took about 53 years of CPU time.N=25 has been confirmed by the NTU 25Queen Project at National Taiwan University and Ming Chuan University, led by Yuh-Pyng (Arping) Shieh, Jul 26 2005. This computation took 26613 days CPU time.

  N=26 as calculated by Queens(AT)TUD [http://queens.inf.tu-dresden.de/]. - Thomas B. Preußer, Jul 11 2009

  N=27 as calculated by the Q27 Project [https://github.com/preusser/q27]. - Thomas B. Preußer, Sep 23 2016



*****************************
このぺーじにはなにがあるのか
*****************************

具体的にこのページにはNクイーンのプログラムがある。

コンパイル
$ gcc -pthread -O3 -Wall 07_**NQueen.c -o NQueen 

実行
$ ./NQueen


を試して欲しい。

Nクイーンの解決には処理を分解して一つ一つ丁寧に理解すべくステップが必要だ。
最初はステップ１のソースを何度も見て書いて理解するしかない。
もちろん、簡単なだけに解決時間も相当かかる。処理が終わるまでにコーヒーが飲み終わってしまうかもしれない。
ステップ15までくると、およそ１秒もかからずに処理が終了する。１分かかっていたことが１秒で終わることに
興味がわかないかもしれない。がしかし、１００年かかることが１年かからないとしたらどうだろう。
人工知能AI技術は、デバイスの進化、処理の高速化、解法の最適化（アルゴリズム）の三位一体だ。
順番に、とばすことなくじっくりと読み進めて欲しい。たぶん、日本中のNクイーンプログラムをここまで分解して
ステップにまとめているサイトはそう多くはないはずだ。

さらに、このサイトはNクイーンプログラムを複数のプログラム言語で習熟出来る準備がある。
例えば以下の通りだ。

  Java版 N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_N-Queen

  Bash版 N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_Bash

  Lua版  N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_Lua

  C版  N-Queen
  https://github.com/suzukiiichiro/AI_Algorithm_C
 
C版
　およそ全てのプログラム言語の中で最も高速に処理できると言われている。事実そうだ。
　まだ何もわからない初学の人はC言語から始めるべきだ。
　マルチスレッドなど、Javaに比べて複雑に記述する必要がある分、プログラムの端々までの
深い知識が必要だ。C言語マスターは間違いなく、Javaプログラマよりシステム技術を網羅的に深く理解している。

Java版
　C言語があまりにも難解と言われ、取っつきやすい部分を残し、Cでできることを取りこぼさずにできた言語がJavaだ。
マルチスレッドも、C言語よりもわかりやすい。システム技術の表層的な知識だけしかないのであればJavaがよい。
システムがわかった気になる危険な言語でもある。結論から言えばJavaができてもLinuxコマンドやBash、カーネルの
理解は１つも進まない。

Bash版
Linux/UNIXを学ぶのであればBash版をおすすめする。
https://github.com/suzukiiichiro/AI_Algorithm_Bash

  なぜBashなのかは以下に書いておいた。
  https://github.com/suzukiiichiro/AI_Algorithm_Bash/blob/master/002UNIXBasic

  Bashは遅い。だが強力だ。Linuxの力を手に入れることができる。
  どの言語で学ぶのかを迷っているのであれば迷わず「Bash」を選んで欲しい。
  その次はLua->Java->Cだ。

Lua版
スマートフォンアプリが世の中のテクノロジーを牽引しているのは間違いない。
そのアプリ開発で幅を利かせているのがLua言語だ。コンパクトで高速、周りとの相性も良いときている。


上記、どの言語から始めても良いと思う。できる人はどの言語でもすらすら書ける。
では、以下から本題に入る。


*****************************
  N-Queens問題とは
*****************************
 
     Nクイーン問題とは、「8列×8行のチェスボードに8個のクイーンを、互いに効きが
     当たらないように並べよ」という８クイーン問題のクイーン(N)を、どこまで大き
     なNまで解を求めることができるかという問題。
     クイーンとは、チェスで使われているクイーンを指し、チェス盤の中で、縦、横、
     斜めにどこまでも進むことができる駒で、日本の将棋でいう「飛車と角」を合わ
     せた動きとなる。８列×８行で構成される一般的なチェスボードにおける8-Queens
     問題の解は、解の総数は92個である。比較的単純な問題なので、学部レベルの演
     習問題として取り上げられることが多い。
     8-Queens問題程度であれば、人力またはプログラムによる「力まかせ探索」でも
     解を求めることができるが、Nが大きくなると解が一気に爆発し、実用的な時間で
     は解けなくなる。
     現在すべての解が判明しているものは、2004年に電気通信大学でIntel Pentium 4
     Xeon 2.8GHzのプロセッサを68個搭載するPCクラスタ×20日をかけてn=24を解決し、
     世界一に、その後2005 年にニッツァ大学でn=25、2009年にドレスデン工科大学で
     N-26、さらに2016年に同工科大学でN=27の解を求めることに成功している。
     JeffSommers氏のビット演算を用いたエレガントなアルゴリズムに加え、対称解除
     法、並列処理、部分解合成法、圧縮や枝刈りなど、先端技術でワールドレコードが
     次々と更新されている。

 --------------------------------------- 共同通信社   電通大(N24） QJH(GPU)版  高橋謙一郎 Somers版(N22)
18:         666090624         83263591   00:00:00:30  00:00:00:12    00:00:25    00:03:48  00:19:26
19:        4968057848        621012754   00:00:05:08  00:00:00:42    00:03:17    00:29:22  02:31:24
20:       39029188884       4878666808   00:00:40:31  00:00:04:46    00:24:07    03:54:10  20:35:06
21:      314666222712      39333324973   00:05:38:49  00:00:41:37    03:05:28 01:09:17:19                      
22      2691008701644     336376244042   02:02:03:49  00:05:50:02 01:03:08:20                                       
23     24233937684440    3029242658210                02:08:52:30                         
24    227514171973736   28439272956934                21:18:10:31                         
25   2207893435808352  275986683743434
26  22317699616364044 2789712466510289
27 234907967154122528

24 ２００４年４月１１日 電気通信大学　2009年4月 68CPU x 22日
25 ２００５年６月１１日 ProActive      単一CPU換算で５０年以上                                           
26 ２００９年７月１１日 tu-dresden     FPGA ( *1 : 8*22 2.5 GHz-QuadCore systemsに相当（約176 * 4CPU = 704 CPU))  x ２４０日
27 ２０１６年　月　　日 tu-dresden



************************************************
  ステップバイステップでＮ−クイーン問題を最適化
************************************************

 1. ブルートフォース　力任せ探索

 　全ての可能性のある解の候補を体系的に数え上げ、それぞれの解候補が問題の解と
   なるかをチェックする方法
   (※)各行に１個の王妃を配置する組み合わせを再帰的に列挙組み合わせを生成するだ
   けであって8王妃問題を解いているわけではありません

  実行結果
  :
  :
  16777207: 7 7 7 7 7 7 6 6
  16777208: 7 7 7 7 7 7 6 7
  16777209: 7 7 7 7 7 7 7 0
  16777210: 7 7 7 7 7 7 7 1
  16777211: 7 7 7 7 7 7 7 2
  16777212: 7 7 7 7 7 7 7 3
  16777213: 7 7 7 7 7 7 7 4
  16777214: 7 7 7 7 7 7 7 5
  16777215: 7 7 7 7 7 7 7 6
  16777216: 7 7 7 7 7 7 7 7


  ２．配置フラグ（制約テスト高速化）
   パターンを生成し終わってからチェックを行うのではなく、途中で制約を満たさな
   い事が明らかな場合は、それ以降のパターン生成を行わない。
  「手を進められるだけ進めて、それ以上は無理（それ以上進めても解はない）という
  事がわかると一手だけ戻ってやり直す」という考え方で全ての手を調べる方法。
  (※)各行列に一個の王妃配置する組み合わせを再帰的に列挙分枝走査を行っても、組
  み合わせを列挙するだけであって、8王妃問題を解いているわけではありません。
 
  実行結果
  :
  :
  40312: 7 6 5 4 2 1 3 0
  40313: 7 6 5 4 2 3 0 1
  40314: 7 6 5 4 2 3 1 0
  40315: 7 6 5 4 3 0 1 2
  40316: 7 6 5 4 3 0 2 1
  40317: 7 6 5 4 3 1 0 2
  40318: 7 6 5 4 3 1 2 0
  40319: 7 6 5 4 3 2 0 1
  40320: 7 6 5 4 3 2 1 0


  ３．バックトラック
   　各列、対角線上にクイーンがあるかどうかのフラグを用意し、途中で制約を満た
   さない事が明らかな場合は、それ以降のパターン生成を行わない。
   　各列、対角線上にクイーンがあるかどうかのフラグを用意することで高速化を図る。
   　これまでは行方向と列方向に重複しない組み合わせを列挙するものですが、王妃
   は斜め方向のコマをとることができるので、どの斜めライン上にも王妃をひとつだ
   けしか配置できない制限を加える事により、深さ優先探索で全ての葉を訪問せず木
   を降りても解がないと判明した時点で木を引き返すということができます。
 
 
  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               0            0.00
 5:           10               0            0.00
 6:            4               0            0.00
 7:           40               0            0.00
 8:           92               0            0.00
 9:          352               0            0.00
10:          724               0            0.00
11:         2680               0            0.01
12:        14200               0            0.05
13:        73712               0            0.30
14:       365596               0            1.93
15:      2279184               0           13.50
16:     14772512               0         1:39.30
17:     95815104               0        12:29.59


 ４．対称解除法
     一つの解には、盤面を９０度、１８０度、２７０度回転、及びそれらの鏡像の合計
     ８個の対称解が存在する。対照的な解を除去し、ユニーク解から解を求める手法。
 
 ■ユニーク解の判定方法
   全探索によって得られたある１つの解が、回転・反転などによる本質的に変わること
 のない変換によって他の解と同型となるものが存在する場合、それを別の解とはしない
 とする解の数え方で得られる解を「ユニーク解」といいます。つまり、ユニーク解とは、
 全解の中から回転・反転などによる変換によって同型になるもの同士をグループ化する
 ことを意味しています。
 
   従って、ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、こ
 の解はユニーク解ではないという定まった判定方法はありません。ユニーク解であるか
 どうかの判断はユニーク解の個数を数える目的の為だけに各個人が自由に定義すること
 になります。もちろん、どのような定義をしたとしてもユニーク解の個数それ自体は変
 わりません。
 
   さて、Ｎクイーン問題は正方形のボードで形成されるので回転・反転による変換パター
 ンはぜんぶで８通りあります。だからといって「全解数＝ユニーク解数×８」と単純には
 いきません。ひとつのグループの要素数が必ず８個あるとは限らないのです。Ｎ＝５の
 下の例では要素数が２個のものと８個のものがあります。


 Ｎ＝５の全解は１０、ユニーク解は２なのです。
 
 グループ１: ユニーク解１つ目
--- Q-  - Q---
 Q----  ---- Q
-- Q--  -- Q--
---- Q   Q----
- Q---  --- Q-
 
 グループ２: ユニーク解２つ目
---- Q   Q----  -- Q--  -- Q--  --- Q-  - Q---   Q----  ---- Q
-- Q--  -- Q--   Q----  ---- Q  - Q---  --- Q-  --- Q-  - Q---
 Q----  ---- Q  --- Q-  - Q---  ---- Q   Q----  - Q---  --- Q-
--- Q-  - Q---  - Q---  --- Q-  -- Q--  -- Q--  ---- Q   Q----
- Q---  --- Q-  ---- Q   Q----   Q----  ---- Q  -- Q--  -- Q--

 
   それでは、ユニーク解を判定するための定義付けを行いますが、次のように定義する
 ことにします。各行のクイーンが右から何番目にあるかを調べて、最上段の行から下
 の行へ順番に列挙します。そしてそれをＮ桁の数値として見た場合に最小値になるもの
 をユニーク解として数えることにします。尚、このＮ桁の数を以後は「ユニーク判定値」
 と呼ぶことにします。
 
---- Q   0
-- Q--   2
 Q----   4  --->  0 2 4 1 3 (ユニーク判定値)
--- Q-   1
- Q---   3
 
 
   探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定
 するには「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるか
 を調べる」ことになります。しかし結論から先にいえば、ユニーク解とは成り得ないこ
 とが明確なパターンを探索中に切り捨てるある枝刈りを組み込むことにより、３通りの
 変換を試みるだけでユニーク解の判定が可能になります。
  
 
 ■ユニーク解の個数を求める
   先ず最上段の行のクイーンの位置に着目します。その位置が左半分の領域にあればユ
 ニーク解には成り得ません。何故なら左右反転によって得られるパターンのユニーク判
 定値の方が確実に小さくなるからです。また、Ｎが奇数の場合に中央にあった場合はど
 うでしょう。これもユニーク解には成り得ません。何故なら仮に中央にあった場合、そ
 れがユニーク解であるためには少なくとも他の外側の３辺におけるクイーンの位置も中
 央になければならず、それは互いの効き筋にあたるので有り得ません。


 ***********************************************************************
 最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
 ***********************************************************************
 
   次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。他の３つ
 の角にクイーンを置くことはできないので(効き筋だから）、ユニーク解であるかどうか
 を判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになり
 ます。突き詰めれば、
 
 [上から２行目のクイーンの位置が右から何番目にあるか]
 [右から２列目のクイーンの位置が上から何番目にあるか]
 

 を比較するだけで判定することができます。この２つの値が同じになることはないからです。
 
       3 0
       ↓↓
---- Q ←0
- Q--- ←3
-----         上から２行目のクイーンの位置が右から４番目にある。
--- Q-         右から２列目のクイーンの位置が上から４番目にある。
-----         しかし、互いの効き筋にあたるのでこれは有り得ない。
 
   結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得
 られる解は総てユニーク解であることが保証されます。
 
---- X Q
- Q-- X-
---- X-
---- X-
------
------
 
   次に右端以外にクイーンがある場合を考えてみます。オリジナルがユニーク解である
 ためには先ず下図の X への配置は禁止されます。よって、その枝刈りを先ず入れておき
 ます。
 
 X X--- Q X X
 X------ X
--------
--------
--------
--------
 X------ X
 X X---- X X
 
   次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能
 性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。従っ
 て、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいこと
 になります。
 
 X X x x x Q X X
 X--- x x x X
 C-- x- x- x
-- x-- x--
- x--- x--
 x---- x- A
 X---- x- X
 X X B-- x X X


 ■ユニーク解から全解への展開
   これまでの考察はユニーク解の個数を求めるためのものでした。全解数を求めるには
 ユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。したがって
 探索時間を犠牲にしてしまうことになります。そこで「ユニーク解の個数から全解数を
 導いてしまおう」という試みが考えられます。これは、左右反転によるパターンの探索
 を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。そしてそ
 れを実現させるには「あるユニーク解が属するグループの要素数はいくつあるのか」と
 いう考察が必要になってきます。
 
   最初に、クイーンが右上角にあるユニーク解を考えます。斜軸で反転したパターンが
 オリジナルと同型になることは有り得ないことと(×２)、右上角のクイーンを他の３つの
 角に写像させることができるので(×４)、このユニーク解が属するグループの要素数は必
 ず８個(＝２×４)になります。
 
   次に、クイーンが右上角以外にある場合は少し複雑になりますが、考察を簡潔にする
 ために次の事柄を確認します。

 TOTAL=(COUNT8 * 8)+(COUNT4 * 4)+(COUNT2 * 2);
  (1)90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
    ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
    ジナルと同型になる。  

    COUNT2 * 2
 
  (2)90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナ
    ルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有
    り得る。 

    COUNT4 * 4
 
  (3)(1)に該当するユニーク解が属するグループの要素数は、左右反転させたパターンを
       加えて２個しかありません。(2)に該当するユニーク解が属するグループの要素数は、
       180度回転させて同型になる場合は４個(左右反転×縦横回転)、そして180度回転させても
       オリジナルと異なる場合は８個になります。(左右反転×縦横回転×上下反転)
 
    COUNT8 * 8 

   以上のことから、ひとつひとつのユニーク解が上のどの種類に該当するのかを調べる
 ことにより全解数を計算で導き出すことができます。探索時間を短縮させてくれる枝刈
 りを外す必要がなくなったというわけです。 
 
   UNIQUE  COUNT2     +  COUNT4     +  COUNT8
   TOTAL (COUNT2 * 2)+(COUNT4 * 4)+(COUNT8 * 8)

 　これらを実現すると、前回のNQueen3()よりも実行速度が遅くなります。
 　なぜなら、対称・反転・斜軸を反転するための処理が加わっているからです。
 ですが、今回の処理を行うことによって、さらにNQueen5()では、処理スピードが飛躍的に高速化されます。そのためにも今回のアルゴリズム実装は必要なのです。

  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               1            0.00
 5:           10               2            0.00
 6:            4               1            0.00
 7:           40               6            0.00
 8:           92              12            0.00
 9:          352              46            0.00
10:          724              92            0.00
11:         2680             341            0.00
12:        14200            1787            0.01
13:        73712            9233            0.10
14:       365596           45752            0.50
15:      2279184          285053            3.39
16:     14772512         1846955           21.32
17:     95815104        11977939         2:40.86


 * ５．枝刈りと最適化
 * 　単純ですのでソースのコメントを見比べて下さい。
 *   単純ではありますが、枝刈りの効果は絶大です。

   実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               1            0.00
 5:           10               2            0.00
 6:            4               1            0.00
 7:           40               6            0.00
 8:           92              12            0.00
 9:          352              46            0.00
10:          724              92            0.00
11:         2680             341            0.00
12:        14200            1787            0.01
13:        73712            9233            0.08
14:       365596           45752            0.43
15:      2279184          285053            2.86
16:     14772512         1846955           18.03
17:     95815104        11977939         2:15.80

 ６．ビットマップ
   ビット演算を使って高速化 状態をビットマップにパックし、処理する
   単純なバックトラックよりも２０〜３０倍高速
 
 　ビットマップであれば、シフトにより高速にデータを移動できる。
  フラグ配列ではデータの移動にO(N)の時間がかかるが、ビットマップであればO(1)
  フラグ配列のように、斜め方向に 2*N-1の要素を用意するのではなく、Nビットで充
  分。

 　配置可能なビット列を flags に入れ、-flags & flags で順にビットを取り出し処理。
 　バックトラックよりも２０−３０倍高速。
 
 ===================
 考え方 1
 ===================

 　Ｎ×ＮのチェスボードをＮ個のビットフィールドで表し、ひとつの横列の状態をひと
 つのビットフィールドに対応させます。(クイーンが置いてある位置のビットをONに
 する)
 　そしてバックトラッキングは0番目のビットフィールドから「下に向かって」順にい
 ずれかのビット位置をひとつだけONにして進めていきます。

 
  - - - - - Q - -    00000100 0番目のビットフィールド
  - - - Q - - - -    00010000 1番目のビットフィールド
  - - - - - - Q -    00000010 2番目のビットフィールド
  Q - - - - - - -    10000000 3番目のビットフィールド
  - - - - - - - Q    00000001 4番目のビットフィールド
  - Q - - - - - -    01000000 5番目のビットフィールド
  - - - - Q - - -    00001000 6番目のビットフィールド
  - - Q - - - - -    00100000 7番目のビットフィールド


 ===================
 考え方 2
 ===================

 次に、効き筋をチェックするためにさらに３つのビットフィールドを用意します。

 1. 左下に効き筋が進むもの: left 
 2. 真下に効き筋が進むもの: down
 3. 右下に効き筋が進むもの: right

次に、斜めの利き筋を考えます。
 上図の場合、
 1列目の右斜め上の利き筋は 3 番目 (0x08)
 2列目の右斜め上の利き筋は 2 番目 (0x04) になります。
 この値は 0 列目のクイーンの位置 0x10 を 1 ビットずつ「右シフト」すれば求める
 ことができます。
 また、左斜め上の利き筋の場合、1 列目では 5 番目 (0x20) で 2 列目では 6 番目 (0x40)
になるので、今度は 1 ビットずつ「左シフト」すれば求めることができます。

つまり、右シフトの利き筋を right、左シフトの利き筋を left で表すことで、クイー
ンの効き筋はrightとleftを1 ビットシフトするだけで求めることができるわけです。

  *-------------
  | . . . . . .
  | . . . -3. .  0x02 -|
  | . . -2. . .  0x04  |(1 bit 右シフト right)
  | . -1. . . .  0x08 -|
  | Q . . . . .  0x10 ←(Q の位置は 4   down)
  | . +1. . . .  0x20 -| 
  | . . +2. . .  0x40  |(1 bit 左シフト left)  
  | . . . +3. .  0x80 -|
  *-------------
  図：斜めの利き筋のチェック

 n番目のビットフィールドからn+1番目のビットフィールドに探索を進めるときに、そ
 の３つのビットフィールドとn番目のビットフィールド(bit)とのOR演算をそれぞれ行
 います。leftは左にひとつシフトし、downはそのまま、rightは右にひとつシフトして
 n+1番目のビットフィールド探索に渡してやります。

 left : (left |bit)<<1
 right: (right|bit)>>1
 down :   down|bit


 ===================
 考え方 3
 ===================

   n+1番目のビットフィールドの探索では、この３つのビットフィールドをOR演算した
 ビットフィールドを作り、それがONになっている位置は効き筋に当たるので置くことが
 できない位置ということになります。次にその３つのビットフィールドをORしたビッ
 トフィールドをビット反転させます。つまり「配置可能なビットがONになったビットフィー
 ルド」に変換します。そしてこの配置可能なビットフィールドを bitmap と呼ぶとして、
 次の演算を行なってみます。
 
 bit = -bitmap & bitmap; //一番右のビットを取り出す
 
   この演算式の意味を理解するには負の値がコンピュータにおける２進法ではどのよう
 に表現されているのかを知る必要があります。負の値を２進法で具体的に表わしてみる
 と次のようになります。
 
  00000011   3
  00000010   2
  00000001   1
  00000000   0
  11111111  -1
  11111110  -2
  11111101  -3
 
   正の値nを負の値-nにするときは、nをビット反転してから+1されています。そして、
 例えばn=22としてnと-nをAND演算すると下のようになります。nを２進法で表したときの
 一番下位のONビットがひとつだけ抽出される結果が得られるのです。極めて簡単な演算
 によって1ビット抽出を実現させていることが重要です。
 
      00010110   22
  AND 11101010  -22
 ------------------
      00000010
 
   さて、そこで下のようなwhile文を書けば、このループは bitmap のONビットの数の
 回数だけループすることになります。配置可能なパターンをひとつずつ全く無駄がなく
 生成されることになります。
 
 while (bitmap) {
     bit = -bitmap & bitmap;
     bitmap ^= bit;
     //ここでは配置可能なパターンがひとつずつ生成される(bit) 
 }


 ６．ビットマップ
  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               1            0.00
 5:           10               2            0.00
 6:            4               1            0.00
 7:           40               6            0.00
 8:           92              12            0.00
 9:          352              46            0.00
10:          724              92            0.00
11:         2680             341            0.00
12:        14200            1787            0.01
13:        73712            9233            0.06
14:       365596           45752            0.34
15:      2279184          285053            2.15
16:     14772512         1846955           14.39
17:     95815104        11977939         1:40.79


 <>７．ビットマップ+対称解除法          NQueen07() N17: 2:24
 *
 *     一つの解には、盤面を９０度、１８０度、２７０度回転、及びそれらの鏡像の合計
 *     ８個の対称解が存在する。対照的な解を除去し、ユニーク解から解を求める手法。
 * 
 * ■ユニーク解の判定方法
 *   全探索によって得られたある１つの解が、回転・反転などによる本質的に変わること
 * のない変換によって他の解と同型となるものが存在する場合、それを別の解とはしない
 * とする解の数え方で得られる解を「ユニーク解」といいます。つまり、ユニーク解とは、
 * 全解の中から回転・反転などによる変換によって同型になるもの同士をグループ化する
 * ことを意味しています。
 * 
 *   従って、ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、こ
 * の解はユニーク解ではないという定まった判定方法はありません。ユニーク解であるか
 * どうかの判断はユニーク解の個数を数える目的の為だけに各個人が自由に定義すること
 * になります。もちろん、どのような定義をしたとしてもユニーク解の個数それ自体は変
 * わりません。
 * 
 *   さて、Ｎクイーン問題は正方形のボードで形成されるので回転・反転による変換パター
 * ンはぜんぶで８通りあります。だからといって「全解数＝ユニーク解数×８」と単純には
 * いきません。ひとつのグループの要素数が必ず８個あるとは限らないのです。Ｎ＝５の
 * 下の例では要素数が２個のものと８個のものがあります。
 *
 *
 * Ｎ＝５の全解は１０、ユニーク解は２なのです。
 * 
 * グループ１: ユニーク解１つ目
 * - - - Q -   - Q - - -
 * Q - - - -   - - - - Q
 * - - Q - -   - - Q - -
 * - - - - Q   Q - - - -
 * - Q - - -   - - - Q -
 * 
 * グループ２: ユニーク解２つ目
 * - - - - Q   Q - - - -   - - Q - -   - - Q - -   - - - Q -   - Q - - -   Q - - - -   - - - - Q
 * - - Q - -   - - Q - -   Q - - - -   - - - - Q   - Q - - -   - - - Q -   - - - Q -   - Q - - -
 * Q - - - -   - - - - Q   - - - Q -   - Q - - -   - - - - Q   Q - - - -   - Q - - -   - - - Q -
 * - - - Q -   - Q - - -   - Q - - -   - - - Q -   - - Q - -   - - Q - -   - - - - Q   Q - - - -
 * - Q - - -   - - - Q -   - - - - Q   Q - - - -   Q - - - -   - - - - Q   - - Q - -   - - Q - -
 *
 * 
 *   それでは、ユニーク解を判定するための定義付けを行いますが、次のように定義する
 * ことにします。各行のクイーンが右から何番目にあるかを調べて、最上段の行から下
 * の行へ順番に列挙します。そしてそれをＮ桁の数値として見た場合に最小値になるもの
 * をユニーク解として数えることにします。尚、このＮ桁の数を以後は「ユニーク判定値」
 * と呼ぶことにします。
 * 
 * - - - - Q   0
 * - - Q - -   2
 * Q - - - -   4   --->  0 2 4 1 3  (ユニーク判定値)
 * - - - Q -   1
 * - Q - - -   3
 * 
 * 
 *   探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定
 * するには「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるか
 * を調べる」ことになります。しかし結論から先にいえば、ユニーク解とは成り得ないこ
 * とが明確なパターンを探索中に切り捨てるある枝刈りを組み込むことにより、３通りの
 * 変換を試みるだけでユニーク解の判定が可能になります。
 *  
 * 
  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               1            0.00
 5:           10               2            0.00
 6:            4               1            0.00
 7:           40               6            0.00
 8:           92              12            0.00
 9:          352              46            0.00
10:          724              92            0.00
11:         2680             341            0.00
12:        14200            1787            0.02
13:        73712            9233            0.10
14:       365596           45752            0.53
15:      2279184          285053            3.46
16:     14772512         1846955           26.79
17:     95815104        11977939         3:06.11


 ８．ビットマップ＋クイーンの場所で分岐
 *
 * ■ユニーク解の個数を求める
 *   先ず最上段の行のクイーンの位置に着目します。その位置が左半分の領域にあればユ
 * ニーク解には成り得ません。何故なら左右反転によって得られるパターンのユニーク判
 * 定値の方が確実に小さくなるからです。また、Ｎが奇数の場合に中央にあった場合はど
 * うでしょう。これもユニーク解には成り得ません。何故なら仮に中央にあった場合、そ
 * れがユニーク解であるためには少なくとも他の外側の３辺におけるクイーンの位置も中
 * 央になければならず、それは互いの効き筋にあたるので有り得ません。
 *
 *
 * ***********************************************************************
 * 最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
 * ***********************************************************************
 * 
 *   次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。他の３つ
 * の角にクイーンを置くことはできないので(効き筋だから）、ユニーク解であるかどうか
 * を判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになり
 * ます。突き詰めれば、
 * 
 * [上から２行目のクイーンの位置が右から何番目にあるか]
 * [右から２列目のクイーンの位置が上から何番目にあるか]
 * 
 *
 * を比較するだけで判定することができます。この２つの値が同じになることはないからです。
 * 
 *       3 0
 *       ↓↓
 * - - - - Q ←0
 * - Q - - - ←3
 * - - - - -         上から２行目のクイーンの位置が右から４番目にある。
 * - - - Q -         右から２列目のクイーンの位置が上から４番目にある。
 * - - - - -         しかし、互いの効き筋にあたるのでこれは有り得ない。
 * 
 *   結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得
 * られる解は総てユニーク解であることが保証されます。
 * 
 * - - - - X Q
 * - Q - - X -
 * - - - - X -
 * - - - - X -
 * - - - - - -
 * - - - - - -
 * 
 *   次に右端以外にクイーンがある場合を考えてみます。オリジナルがユニーク解である
 * ためには先ず下図の X への配置は禁止されます。よって、その枝刈りを先ず入れておき
 * ます。
 * 
 * X X - - - Q X X
 * X - - - - - - X
 * - - - - - - - -
 * - - - - - - - -
 * - - - - - - - -
 * - - - - - - - -
 * X - - - - - - X
 * X X - - - - X X
 * 
 *   次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能
 * 性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。従っ
 * て、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいこと
 * になります。
 * 
 * X X x x x Q X X
 * X - - - x x x X
 * C - - x - x - x
 * - - x - - x - -
 * - x - - - x - -
 * x - - - - x - A
 * X - - - - x - X
 * X X B - - x X X
 *
 *
 * ■ユニーク解から全解への展開
 *   これまでの考察はユニーク解の個数を求めるためのものでした。全解数を求めるには
 * ユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。したがって
 * 探索時間を犠牲にしてしまうことになります。そこで「ユニーク解の個数から全解数を
 * 導いてしまおう」という試みが考えられます。これは、左右反転によるパターンの探索
 * を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。そしてそ
 * れを実現させるには「あるユニーク解が属するグループの要素数はいくつあるのか」と
 * いう考察が必要になってきます。
 * 
 *   最初に、クイーンが右上角にあるユニーク解を考えます。斜軸で反転したパターンが
 * オリジナルと同型になることは有り得ないことと(×２)、右上角のクイーンを他の３つの
 * 角に写像させることができるので(×４)、このユニーク解が属するグループの要素数は必
 * ず８個(＝２×４)になります。
 * 
 *   次に、クイーンが右上角以外にある場合は少し複雑になりますが、考察を簡潔にする
 * ために次の事柄を確認します。
 *
 * TOTAL = (COUNT8 * 8) + (COUNT4 * 4) + (COUNT2 * 2);
 *   (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
 *    ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
 *    ジナルと同型になる。  
 *
 *    COUNT2 * 2
 * 
 *   (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナ
 *    ルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有
 *    り得る。 
 *
 *    COUNT4 * 4
 * 
 *   (3) (1) に該当するユニーク解が属するグループの要素数は、左右反転させたパターンを
 *       加えて２個しかありません。(2)に該当するユニーク解が属するグループの要素数は、
 *       180度回転させて同型になる場合は４個(左右反転×縦横回転)、そして180度回転させても
 *       オリジナルと異なる場合は８個になります。(左右反転×縦横回転×上下反転)
 * 
 *    COUNT8 * 8 
 *
 *   以上のことから、ひとつひとつのユニーク解が上のどの種類に該当するのかを調べる
 * ことにより全解数を計算で導き出すことができます。探索時間を短縮させてくれる枝刈
 * りを外す必要がなくなったというわけです。 
 * 
 *   UNIQUE  COUNT2      +  COUNT4      +  COUNT8
 *   TOTAL  (COUNT2 * 2) + (COUNT4 * 4) + (COUNT8 * 8)
 *
 * 　これらを実現すると、前回のNQueen3()よりも実行速度が遅くなります。
 * 　なぜなら、対称・反転・斜軸を反転するための処理が加わっているからです。
 * ですが、今回の処理を行うことによって、さらにNQueen5()では、処理スピードが飛
 * 躍的に高速化されます。そのためにも今回のアルゴリズム実装は必要なのです。
 *
  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               1            0.00
 5:           10               2            0.00
 6:            4               1            0.00
 7:           40               6            0.00
 8:           92              12            0.00
 9:          352              46            0.00
10:          724              92            0.00
11:         2680             341            0.00
12:        14200            1787            0.01
13:        73712            9233            0.08
14:       365596           45752            0.43
15:      2279184          285053            2.86
16:     14772512         1846955           18.03
17:     95815104        11977939         2:15.80

  ９．ビットマップ＋枝刈りと最適化

  前章のコードは全ての解を求めた後に、ユニーク解以外の対称解を除去していた
  ある意味、「生成検査法（generate ＆ test）」と同じである
  問題の性質を分析し、バックトラッキング/前方検査法と同じように、無駄な探索を省略することを考える
  ユニーク解に対する左右対称解を予め削除するには、1行目のループのところで、
  右半分だけにクイーンを配置するようにすればよい
  Nが奇数の場合、クイーンを1行目中央に配置する解は無い。
  他の3辺のクィーンが中央に無い場合、その辺が上辺に来るよう回転し、場合により左右反転することで、
  最小値解とすることが可能だから、中央に配置したものしかユニーク解には成り得ない
  しかし、上辺とその他の辺の中央にクィーンは互いの効きになるので、配置することが出来ない


  1. １行目角にクイーンがある場合、とそうでない場合で処理を分ける
    １行目かどうかの条件判断はループ外に出してもよい
    処理時間的に有意な差はないので、分かりやすいコードを示した
  2.１行目角にクイーンがある場合、回転対称形チェックを省略することが出来る
    １行目角にクイーンがある場合、他の角にクイーンを配置することは不可
    鏡像についても、主対角線鏡像のみを判定すればよい
    ２行目、２列目を数値とみなし、２行目＜２列目という条件を課せばよい

  １行目角にクイーンが無い場合、クイーン位置より右位置の８対称位置にクイーンを置くことはできない
  置いた場合、回転・鏡像変換により得られる状態のユニーク判定値が明らかに大きくなる
    ☓☓・・・Ｑ☓☓
    ☓・・・／｜＼☓
    ｃ・・／・｜・rt
    ・・／・・｜・・
    ・／・・・｜・・
    lt・・・・｜・ａ
    ☓・・・・｜・☓
    ☓☓ｂ・・dn☓☓
    
  １行目位置が確定した時点で、配置可能位置を計算しておく（☓の位置）
  lt, dn, lt 位置は効きチェックで配置不可能となる
  回転対称チェックが必要となるのは、クイーンがａ, ｂ, ｃにある場合だけなので、
  90度、180度、270度回転した状態のユニーク判定値との比較を行うだけで済む


  実行結果
 N:        Total       Unique        hh:mm:ss.ms
 2:            0               0            0.00
 3:            0               0            0.00
 4:            2               1            0.00
 5:           10               2            0.00
 6:            4               1            0.00
 7:           40               6            0.00
 8:           92              12            0.00
 9:          352              46            0.00
10:          724              92            0.00
11:         2680             341            0.00
12:        14200            1787            0.00
13:        73712            9233            0.01
14:       365596           45752            0.06
15:      2279184          285053            0.34
16:     14772512         1846955            2.19
17:     95815104        11977939           15.30



  １０．もっとビットマップ すごく速い！ 高橋謙一郎様（takaken版）の労作
  実行結果
 N:           Total          Unique days hh:mm:ss.--
 2:               0                0            0.00
 3:               0                0            0.00
 4:               2                1            0.00
 5:              10                2            0.00
 6:               4                1            0.00
 7:              40                6            0.00
 8:              92               12            0.00
 9:             352               46            0.00
10:             724               92            0.00
11:            2680              341            0.00
12:           14200             1787            0.00
13:           73712             9233            0.01
14:          365596            45752            0.06
15:         2279184           285053            0.35
16:        14772512          1846955            2.23
17:        95815104         11977939           15.76


  11.マルチスレッド（構造体）
  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.01
14:          365596            45752          00:00:00:00.05
15:         2279184           285053          00:00:00:00.32
16:        14772512          1846955          00:00:00:02.10
17:        95815104         11977939          00:00:00:14.53

  12.マルチスレッド（pthread)
  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.01
14:          365596            45752          00:00:00:00.05
15:         2279184           285053          00:00:00:00.31
16:        14772512          1846955          00:00:00:02.05
17:        95815104         11977939          00:00:00:14.12


  13.マルチスレッド(join）
  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.01
14:          365596            45752          00:00:00:00.05
15:         2279184           285053          00:00:00:00.31
16:        14772512          1846955          00:00:00:02.02
17:        95815104         11977939          00:00:00:14.05

  14．マルチスレッド(mutex) 
  mutexによるロックとロック解除の頻発がボトルネックとなり、
  並行処理のメリットが出ません。

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             344               45          00:00:00:00.00
10:             716               91          00:00:00:00.00
11:            2600              331          00:00:00:00.00
12:           13712             1726          00:00:00:00.00
13:           71320             8934          00:00:00:00.00
14:          351364            43973          00:00:00:00.01
15:         2175752           272124          00:00:00:00.10
16:        14085600          1761091          00:00:00:00.73
17:        92161400         11521226          00:00:00:05.70


 15．マルチスレッド(脱mutex COUNT強化)NQueen15() N17=    05.70
 mutex１つをロック・ロック解除で使い回すことでボトルネックが発生しました。
 また、mutexをスレッドの数だけ生成し、スレッド毎にロック/ロック解除を
 繰り返すことでオーバーヘッドは少なくなったものの、依然としてシングルスレッ
 ドよりも速度は遅くなることとなりました。
 高速化を実現するならばmutexで排他処理を行うよりも、アトミックに
 メモリアクセスする方が良さそうです。
 排他処理に必要な箇所はCOUNT++する箇所となります。
 具体的にはカウントする変数をスレッド毎の配列に格納し、
 COUNT2[BOUND1] COUNT4[BOUND1] COUNT8[BOUND1]で実装します。

 実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.01
15:         2279184           285053          00:00:00:00.09
16:        14772512          1846955          00:00:00:00.69
17:        95815104         11977939          00:00:00:05.66

   16．マルチスレッド(アドレスとポインタ) 
  実行結果 
 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.13
16:        14772512          1846955          00:00:00:00.83
17:        95815104         11977939          00:00:00:06.11

  
 17．アドレスとポインタ(脱構造体)     NQueen17() N17: 00:03
  実行結果 
 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.16
16:        14772512          1846955          00:00:00:00.95
17:        95815104         11977939          00:00:00:06.62

   
 <>18．アドレスとポインタ(脱配列)       NQueen18()
  実行結果 
 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.15
16:        14772512          1846955          00:00:00:00.97
17:        95815104         11977939          00:00:00:06.67


 <>19．アドレスとポインタ(考察４)

1,構造体のみ追加
void backTrack2(int y,int left,int down,int right,struct local *l,int *si,
     int *bo,int *bo2,int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.15
16:        14772512          1846955        0000:00:00.99
17:        95815104         11977939        0000:00:06.12
2,SIZEEを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *bo,int *bo2,int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.16
16:        14772512          1846955        0000:00:00.93
17:        95815104         11977939        0000:00:05.74
18:       666090624         83263591        0000:00:39.43
3,BOUND1を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *bo2,int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.14
16:        14772512          1846955        0000:00:00.88
17:        95815104         11977939        0000:00:05.55
18:       666090624         83263591        0000:00:38.07
4,BOUND2を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *ma,int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.13
16:        14772512          1846955        0000:00:00.80
17:        95815104         11977939        0000:00:05.23
18:       666090624         83263591        0000:00:35.71
5,MASKを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *sm,int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.15
16:        14772512          1846955        0000:00:00.79
17:        95815104         11977939        0000:00:05.10
18:       666090624         83263591        0000:00:34.74
6,SIDEMASKを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *lm,int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.12
16:        14772512          1846955        0000:00:00.82
17:        95815104         11977939        0000:00:05.10
18:       666090624         83263591        0000:00:35.18
7,LASTMASKを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *to,int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.11
16:        14772512          1846955        0000:00:00.74
17:        95815104         11977939        0000:00:04.71
18:       666090624         83263591        0000:00:32.08
8,TOPBITを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *en,int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.14
16:        14772512          1846955        0000:00:00.70
17:        95815104         11977939        0000:00:04.50
18:       666090624         83263591        0000:00:30.82
9,ENDBITを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     int *p,long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.65
17:        95815104         11977939        0000:00:04.31
18:       666090624         83263591        0000:00:29.26
10,aBoardを移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     long *c2,long *c4,long *c8){
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.58
17:        95815104         11977939        0000:00:03.69
18:       666090624         83263591        0000:00:24.89
10,COUNT2を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     long *c4,long *c8){
15:         2279184           285053        0000:00:00.11
16:        14772512          1846955        0000:00:00.56
17:        95815104         11977939        0000:00:03.68
18:       666090624         83263591        0000:00:24.65
11,COUNT4を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     long *c8){
15:         2279184           285053        0000:00:00.09
16:        14772512          1846955        0000:00:00.56
17:        95815104         11977939        0000:00:03.65
18:       666090624         83263591        0000:00:24.94
12,COUNT8を移動
void backTrack2(int y,int left,int down,int right,struct local *l,
     ){
15:         2279184           285053        0000:00:00.11
16:        14772512          1846955        0000:00:00.65
17:        95815104         11977939        0000:00:04.21
18:       666090624         83263591        0000:00:28.76
13,COUNT2,COUNT4,COUNT8を外出しにする。SIDEMASKを変数に入れて使う
15:         2279184           285053        0000:00:00.10
16:        14772512          1846955        0000:00:00.57
17:        95815104         11977939        0000:00:03.66
18:       666090624         83263591        0000:00:24.70

 N:           Total           Unique          hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.15
16:        14772512          1846955          00:00:00:00.97
17:        95815104         11977939          00:00:00:06.28




 <>20．アドレスとポインタ(考察５)       NQueen20()
 配列カウンターはアクセスが多いので構造体から出して
 グローバル変数に。さらにスレッド対応にするため、
 カウンター配列とした。

long C2[MAX];
long C4[MAX];
long C8[MAX];

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.16
16:        14772512          1846955          00:00:00:01.06
17:        95815104         11977939          00:00:00:07.37


 <>21．アドレスとポインタ(考察６) 

void symmetryOps_bm(void *args,long *C2,long *C4,long *C8);
  ↓
void symmetryOps_bm(local *l,long *C2,long *C4,long *C8);

  こうすることによって以下の宣言が不要となった
  local *l=(local *)args;

対象関数は以下の通り
void symmetryOps_bm(local *l,long *C2,long *C4,long *C8);
void backTrack2(int y,int left,int down,int right,local *l,long *C2,long *C4,long *C8);
void backTrack1(int y,int left,int down,int right,local *l,long *C8);

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.16
16:        14772512          1846955          00:00:00:01.06
17:        95815104         11977939          00:00:00:07.57



 <>22．アドレスとポインタ(考察７)
 比較的どの関数でもアクセスの多い siE変数はG.siEという
 ふうに構造体に格納されているが、関数の先頭で変数に代入し、
 メソッド内での構造体へのアクセス頻度を減らす。

  int _siE=G.siE;

  //90度回転
  if(l->aB[l->B2]==1){ own=1; ptn=2;
    //while(own<=G.siE){ bit=1; you=G.siE;
    while(own<=_siE){ bit=1; you=_siE;


  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.02
15:         2279184           285053          00:00:00:00.16
16:        14772512          1846955          00:00:00:01.06
17:        95815104         11977939          00:00:00:07.55


 <>23．アドレスとポインタ(考察８) 
	SIDEMASKをCOUNT同様にグローバル変数に外だし
	不要なループを除去
　不明な最大値を見直し

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.03
15:         2279184           285053          00:00:00:00.17
16:        14772512          1846955          00:00:00:01.17
17:        95815104         11977939          00:00:00:08.31


 <>24．アドレスとポインタ(完結) 
  カウンター以外の変数を外だししてみたが、カウンター外だし
　ほどの効果を得ることはできなかった。
　なので、ソースの可読性を含めカウンター以外は構造体に含める。
  NQ24はNQ21のソースを拡張して展開することとした。
  さらに外だしすると硬貨があるように見えた配列カウンターも
  構造体の中に含める方がよりNが大きくなると最適化されること
  がわかったので構造体に戻した。

  実行結果 
 N:        Total       Unique        hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.01
15:         2279184           285053          00:00:00:00.09
16:        14772512          1846955          00:00:00:00.62
17:        95815104         11977939          00:00:00:04.19
18:       666090624         83263591          00:00:00:32.44


 <>25．最適化 									        NQueen25() N17=03:70
=== 1 ===
 G構造体に格納していた int si int siE int lTotal int lUniqueを
 グローバル変数に置き換えました。ちょっと速くなりました。

=== 2 ===
 L構造体に格納していたC2/C4/C8カウンターの置き場所を変えて比較

1.
// long C2[MAX]; //グローバル環境に置くと N=17: 08.04
// long C4[MAX];
// long C8[MAX];

2.
//  long C2; // 構造体の中の配列をなくすとN=17: 05.24
//  long C4;
//  long C8;

3. 構造体の中でポインタアクセスにしてみる // N=17 : 05.87
   さらにcallocにより、宣言時に適切なメモリサイズを割り当てる
// int *ab; 
//  l[B1].aB=calloc(G.si,sizeof(int));

4.
  long C2[MAX];//構造体の中の配列を活かすと   N=17: 04.33
  long C4[MAX];
  long C8[MAX];

 よって、カウンターはL構造体の中に配置し、スレッド毎にカウンター
を管理する配列で構築しました。
同様に、カウントする箇所は以下のように書き換えました。

			l->C4[l->B1]++;

これによりちょっと速くなりました。

=== 3 ===
　symmetryOps_bm()/trackBack1()/trackBack2()のメソッドないで宣言されている
ローカル変数を撲滅しました。
　symmetryOps_bm()の中では以下の通りです。

  int own,ptn,you,bit;

こちらは全てL構造体でもち、
　l->own などでアクセスするようにしました。構造体に配置すると遅くなる
　という本をよく見ますが、激しく呼び出されるメソッドで変数が都度生成される
　コストと比べると計測から見れば、構造体で持った方が速いと言うことがわかりました。
これによりちょっと速くなりました。

=== 4 ===
 backTrack1()/backTrack2()のbm以外の変数はbitだけです。こちらは簡単に構造体に
　格納して実装することができました。問題はbm(bitmap)です。
　こちらは、再帰で変化する変数で、スレッド毎に値も変わることから値渡しである
　必要があります。よって関数の引数の中に格納することとしました。

void backTrack2(int y,int left,int down,int right,int bm,local *l){
void backTrack1(int y,int left,int down,int right,int bm,local *l){
これによりちょっと速くなりました。

=== 5 ===
pthreadや構造体 lは　#defineで宣言されるMAX=27を使って初期化していました。
si siEをグローバル変数としたことで、これらもNの値で初期化することとしました。

void *NQueenThread(){
  //pthread_t pt[G.si];//スレッド childThread
  pthread_t pt[si];//スレッド childThread
  //local l[MAX];//構造体 local型 
  local l[si];//構造体 local型 

	CPU affinity
	論理CPUにスレッドを割り当てる

#if _GNU_SOURCE
#define _GNU_SOURCE
#include <sched.h> 
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define handle_error_en(en, msg) do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)
#endif


# run ソース部分：
#ifdef _GNU_SOURCE
  pthread_t thread = pthread_self();
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(l->B1, &cpuset);
  int s=pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
  if (s != 0){ handle_error_en(s, "pthread_setaffinity_np"); }
  s=pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
  if (s != 0){ handle_error_en(s, "pthread_getaffinity_np"); }
  //printf("pid:%10d#l->B1:%2d#cpuset:%d\n",thread,l->B1,&cpuset);
#endif

  実行結果  スレッドが立ってる
pid:139811194939136#l->B1: 7#cpuset:1419517552
pid:139811100808960#l->B1: 4#cpuset:1325387376
pid:139811084023552#l->B1: 3#cpuset:1308601968
pid:139811109201664#l->B1: 5#cpuset:1333780080
pid:139811203331840#l->B1: 8#cpuset:1427910256
pid:139811117594368#l->B1: 6#cpuset:1342172784
pid:139811067238144#l->B1: 2#cpuset:1291816560
pid:139811050452736#l->B1: 1#cpuset:1275031152
16:        14772512          1846955          00:00:00:00.56
pid:139811228509952#l->B1:12#cpuset:1453088368
pid:139811084023552#l->B1:14#cpuset:1308601968
pid:139811211724544#l->B1:10#cpuset:1436302960
pid:139811067238144#l->B1:15#cpuset:1291816560
pid:139811220117248#l->B1:11#cpuset:1444695664
pid:139811050452736#l->B1:16#cpuset:1275031152
pid:139811236902656#l->B1:13#cpuset:1461481072
pid:139811203331840#l->B1: 9#cpuset:1427910256
pid:139811109201664#l->B1: 6#cpuset:1333780080
pid:139811058845440#l->B1: 2#cpuset:1283423856
pid:139811117594368#l->B1: 7#cpuset:1342172784
pid:139811042060032#l->B1: 1#cpuset:1266638448
pid:139811092416256#l->B1: 4#cpuset:1316994672
pid:139811100808960#l->B1: 5#cpuset:1325387376
pid:139811075630848#l->B1: 3#cpuset:1300209264
pid:139811194939136#l->B1: 8#cpuset:1419517552
17:        95815104         11977939          00:00:00:03.63

=== 11 ===
コンパイラ比較
$ /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -v
Apple LLVM version 8.1.0 (clang-802.0.42)
Target: x86_64-apple-darwin16.6.0
Thread model: posix
InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin

15:         2279184           285053          00:00:00:00.16
16:        14772512          1846955          00:00:00:01.02
17:        95815104         11977939          00:00:00:06.55

$ /usr/local/Cellar/llvm/4.0.1/bin/clang -v
clang version 4.0.1 (tags/RELEASE_401/final)
Target: x86_64-apple-darwin16.6.0
Thread model: posix
InstalledDir: /usr/local/bin
Found CUDA installation: /usr/local/cuda, version 7.5

15:         2279184           285053          00:00:00:00.15
16:        14772512          1846955          00:00:00:00.95
17:        95815104         11977939          00:00:00:06.27

$ /opt/local/bin/gcc-mp-7 -v
Using built-in specs.
COLLECT_GCC=/opt/local/bin/gcc-mp-7
COLLECT_LTO_WRAPPER=/opt/local/libexec/gcc/x86_64-apple-darwin16/7.1.1/lto-wrapper
Target: x86_64-apple-darwin16
Configured with: /opt/local/var/macports/build/_opt_bblocal_var_buildworker_ports_build_ports_lang_gcc7/gcc7/work/gcc-7-20170622/configure --prefix=/opt/local --build=x86_64-apple-darwin16 --enable-languages=c,c++,objc,obj-c++,lto,fortran --libdir=/opt/local/lib/gcc7 --includedir=/opt/local/include/gcc7 --infodir=/opt/local/share/info --mandir=/opt/local/share/man --datarootdir=/opt/local/share/gcc-7 --with-local-prefix=/opt/local --with-system-zlib --disable-nls --program-suffix=-mp-7 --with-gxx-include-dir=/opt/local/include/gcc7/c++/ --with-gmp=/opt/local --with-mpfr=/opt/local --with-mpc=/opt/local --with-isl=/opt/local --enable-stage1-checking --disable-multilib --enable-lto --enable-libstdcxx-time --with-build-config=bootstrap-debug --with-as=/opt/local/bin/as --with-ld=/opt/local/bin/ld --with-ar=/opt/local/bin/ar --with-bugurl=https://trac.macports.org/newticket --with-pkgversion='MacPorts gcc7 7-20170622_0'
Thread model: posix
gcc version 7.1.1 20170622 (MacPorts gcc7 7-20170622_0)

15:         2279184           285053          00:00:00:00.12
16:        14772512          1846955          00:00:00:00.71
17:        95815104         11977939          00:00:00:04.64

$ /opt/local/bin/gcc-mp-6 -v
Using built-in specs.
COLLECT_GCC=/opt/local/bin/gcc-mp-6
COLLECT_LTO_WRAPPER=/opt/local/libexec/gcc/x86_64-apple-darwin16/6.3.0/lto-wrapper
Target: x86_64-apple-darwin16
Configured with: /opt/local/var/macports/build/_opt_bblocal_var_buildworker_ports_build_ports_lang_gcc6/gcc6/work/gcc-6.3.0/configure --prefix=/opt/local --build=x86_64-apple-darwin16 --enable-languages=c,c++,objc,obj-c++,lto,fortran --libdir=/opt/local/lib/gcc6 --includedir=/opt/local/include/gcc6 --infodir=/opt/local/share/info --mandir=/opt/local/share/man --datarootdir=/opt/local/share/gcc-6 --with-local-prefix=/opt/local --with-system-zlib --disable-nls --program-suffix=-mp-6 --with-gxx-include-dir=/opt/local/include/gcc6/c++/ --with-gmp=/opt/local --with-mpfr=/opt/local --with-mpc=/opt/local --with-isl=/opt/local --enable-stage1-checking --disable-multilib --enable-lto --enable-libstdcxx-time --with-build-config=bootstrap-debug --with-as=/opt/local/bin/as --with-ld=/opt/local/bin/ld --with-ar=/opt/local/bin/ar --with-bugurl=https://trac.macports.org/newticket --with-pkgversion='MacPorts gcc6 6.3.0_2'
Thread model: posix
gcc version 6.3.0 (MacPorts gcc6 6.3.0_2)

15:         2279184           285053          00:00:00:00.11
16:        14772512          1846955          00:00:00:00.69
17:        95815104         11977939          00:00:00:04.61


$ /usr/local/Cellar/gcc\@5/5.4.0_1/bin/gcc-5 -v
Using built-in specs.
COLLECT_GCC=/usr/local/Cellar/gcc@5/5.4.0_1/bin/gcc-5
COLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc@5/5.4.0_1/libexec/gcc/x86_64-apple-darwin16.3.0/5.4.0/lto-wrapper
Target: x86_64-apple-darwin16.3.0
Configured with: ../configure --build=x86_64-apple-darwin16.3.0 --prefix=/usr/local/Cellar/gcc@5/5.4.0_1 --libdir=/usr/local/Cellar/gcc@5/5.4.0_1/lib/gcc/5 --enable-languages=c,c++,objc,obj-c++,fortran --program-suffix=-5 --with-gmp=/usr/local/opt/gmp --with-mpfr=/usr/local/opt/mpfr --with-mpc=/usr/local/opt/libmpc --with-isl=/usr/local/opt/isl@0.14 --with-system-zlib --enable-libstdcxx-time=yes --enable-stage1-checking --enable-checking=release --enable-lto --disable-werror --with-pkgversion='Homebrew GCC 5.4.0_1' --with-bugurl=https://github.com/Homebrew/homebrew-core/issues --enable-plugin --disable-nls --enable-multilib
Thread model: posix
gcc version 5.4.0 (Homebrew GCC 5.4.0_1)

15:         2279184           285053          00:00:00:00.11
16:        14772512          1846955          00:00:00:00.69
17:        95815104         11977939          00:00:00:04.62

$ /usr/local/Cellar/gcc\@4.9/4.9.4/bin/gcc-4.9 -v
Using built-in specs.
COLLECT_GCC=/usr/local/Cellar/gcc@4.9/4.9.4/bin/gcc-4.9
COLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc@4.9/4.9.4/libexec/gcc/x86_64-apple-darwin16.4.0/4.9.4/lto-wrapper
Target: x86_64-apple-darwin16.4.0
Configured with: ../configure --build=x86_64-apple-darwin16.4.0 --prefix=/usr/local/Cellar/gcc@4.9/4.9.4 --libdir=/usr/local/Cellar/gcc@4.9/4.9.4/lib/gcc/4.9 --enable-languages=c,c++,objc,obj-c++,fortran --program-suffix=-4.9 --with-gmp=/usr/local/opt/gmp@4 --with-mpfr=/usr/local/opt/mpfr@2 --with-mpc=/usr/local/opt/libmpc@0.8 --with-cloog=/usr/local/opt/cloog --with-isl=/usr/local/opt/isl@0.12 --with-system-zlib --enable-libstdcxx-time=yes --enable-stage1-checking --enable-checking=release --enable-lto --with-build-config=bootstrap-debug --disable-werror --with-pkgversion='Homebrew GCC 4.9.4' --with-bugurl=https://github.com/Homebrew/homebrew-core/issues MAKEINFO=missing --enable-plugin --disable-nls --enable-multilib
Thread model: posix
gcc version 4.9.4 (Homebrew GCC 4.9.4)

15:         2279184           285053          00:00:00:00.11
16:        14772512          1846955          00:00:00:00.71
17:        95815104         11977939          00:00:00:04.63


  実行結果 
 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.01
15:         2279184           285053          00:00:00:00.10
16:        14772512          1846955          00:00:00:00.67
17:        95815104         11977939          00:00:00:04.47
18:       666090624         83263591          00:00:00:35.44


 <>26．マルチスレッド再び 							        NQueen26() N17=03.58

  BackTrack1とBackTrack2を独立したスレッドで動作させるため、
  BackTrack1にrun()、BarckTrack2にrun2()とした。
  run()とrun2()は、NQueenThread()から個別に並行処理起動する。

        
          backTrack1                   backTrack2
  最上段の角にクイーンがある   最上段の済みにクイーンがない
          1   2   3   4                1   2   3   4
        +   +   +   +   *            +   +   +   +   *
  1                   Q        1       Q   Q   Q          
        +   +   +   +   *            +   +   +   +   *
  2       Q   Q   Q   Q        2       
        +   +   +   +   *            +   +   +   +   *
  3                            3       
        +   +   +   +   *            +   +   +   +   *
  4                            4
        +   +   +   +   *            +   +   +   +   *


   　　現行では上から２段目まで   最上段のみスレッド対応済み
   　　並行処理している。



runをrunとrun2に分解してそれぞれをスレッド化(兄の労作）
07_25までは以下のCPUは多くて８つが100%になるに過ぎなかったが、
現在は以下の通りすごい勢いでCPUを使うようになった。

top - 05:35:15 up  2:20,  6 users,  load average: 5.46, 3.25, 1.88
Tasks: 304 total,   1 running, 303 sleeping,   0 stopped,   0 zombie
%Cpu0  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu4  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu5  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu6  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu7  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu8  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu9  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu10 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu11 : 12.0 us,  0.0 sy,  0.0 ni, 88.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu12 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu13 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu14 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu15 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu16 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu17 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu18 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu19 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu20 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu21 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu22 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu23 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu24 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu25 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu26 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu27 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu28 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu29 : 88.1 us,  0.0 sy,  0.0 ni, 11.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu30 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu31 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu32 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu33 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu34 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu35 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 61403004 total, 60560672 free,   539100 used,   303232 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 60408604 avail Mem

  実行結果 
 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.01
15:         2279184           285053          00:00:00:00.11
16:        14772512          1846955          00:00:00:00.68
17:        95815104         11977939          00:00:00:04.62
18:       666090624         83263591          00:00:00:36.79



 <>27．もっとマルチスレッド 			        NQueen27() N17=00.78
  
  BackTrack2について修正。
  BackTrack2の処理を最上段のクイーンの場所のスレッドに加えて、
  上から２段目のクイーンも固定しスレッド化。((N-1)xN)


          backTrack1                   backTrack2
  最上段の角にクイーンがある   最上段の済みにクイーンがない
          1   2   3   4                1   2   3   4
        +   +   +   +   *            +   +   +   +   *
  1                   Q        1       Q   Q   Q          
        +   +   +   +   *            +   +   +   +   *
  2       Q   Q   Q   Q        2       Q   Q   Q   Q    ←ここを新設した。
        +   +   +   +   *            +   +   +   +   *
  3                            3       
        +   +   +   +   *            +   +   +   +   *
  4                            4
        +   +   +   +   *            +   +   +   +   *


  26．マルチスレッド再びでは、run()を、 最上段行のクイーンが角にある場合のrun()と、
      最上段行のクイーンが角にない場合のrun2に分解し、 それぞれをスレッド化(兄の労作）したが、
      今回は、backtrack2の処理を最上段から２行目の列数分さらに分割しスレッド化
       ロジック的にはN数倍高速化されるはず。(今回も兄の労作）

			以下の通り、マウントされているCPUが全てフルに稼働していることがわかる。

top - 05:01:06 up 3 days,  1:46,  6 users,  load average: 62.99, 49.02, 22.10
Tasks: 305 total,   1 running, 304 sleeping,   0 stopped,   0 zombie
%Cpu0  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu4  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu5  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu6  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu7  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu8  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu9  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu10 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu11 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu12 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu13 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu14 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu15 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu16 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu17 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu18 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu19 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu20 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu21 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu22 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu23 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu24 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu25 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu26 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu27 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu28 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu29 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu30 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu31 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu32 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu33 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu34 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu35 :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 61403004 total, 60444136 free,   557748 used,   401120 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 60330112 avail Mem 



	実行結果
 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.01
15:         2279184           285053          00:00:00:00.07
16:        14772512          1846955          00:00:00:00.45
17:        95815104         11977939          00:00:00:03.23
18:       666090624         83263591          00:00:00:27.21



 <>28．さらにマルチスレッド(NxN) 			        NQueen28() N17=

  BackTrack2について修正。
  BackTrack2の処理を最上段のクイーン、上から２段目のクイーンに加えて、
  上から３段目のクイーンも固定しスレッド化。((N-1)xNXN)


          backTrack1                   backTrack2
  最上段の角にクイーンがある   最上段の済みにクイーンがない
          1   2   3   4                1   2   3   4
        +   +   +   +   *            +   +   +   +   *
  1                   Q        1       Q   Q   Q          
        +   +   +   +   *            +   +   +   +   *
  2       Q   Q   Q   Q        2       Q   Q   Q   Q    
        +   +   +   +   *            +   +   +   +   *
  3                            3       Q   Q   Q   Q    ←ここを新設した。
        +   +   +   +   *            +   +   +   +   *
  4                            4
        +   +   +   +   *            +   +   +   +   *                    





 従来           
       87654321 backtrack1        
 1行目□□□□□□□□               backtrack1は1行目が右端の場合の処理  
 2行目□□□□□□□□            □  1行目は右端固定  
 3行目□□□□□□□□    □□□□□□□□□  2行目はB1の値に配置
 4行目□□□□□□□□               スレッド数は 1xN=N個        
 5行目□□□□□□□□   
 6行目□□□□□□□□  backtrack2
 7行目□□□□□□□□               backtrack2は1行目のクイーン位置が右端の場合以外 
 8行目□□□□□□□□  □□□□□□□□     1行目が右端以外 B1の値に配置
                             スレッド数は N-1個
 
 07_28NQueen
 スレッド数を増加させるために
 3行目までクイーンの位置を固定値で設定し別スレッドで処理するようにした
 暫定的に3行目まで位置を指定しているが、PCのリソースが許せば、3行目以降も
 位置を指定してスレッド数を増加させることが可能。
 1行追加されるたびにN倍スレッドが細分化されることになる。

       87654321 backtrack1        
 1行目□□□□□□□□              backtrack1は1行目が右端の場合の処理  
 2行目□□□□□□□□          □   1行目は右端固定  
 3行目□□□□□□□□  □□□□□□□□□   2行目はB1の値に配置
 4行目□□□□□□□□  |     |     |         |     3行目はkの値に配置      
 5行目□□□□□□□□  □□□□  □□□□  □□□□  ・・□□□□       
 6行目□□□□□□□□ □□□□  □□□□  □□□□     □□□□ 
 7行目□□□□□□□□       
 8行目□□□□□□□□              スレッド数は 1xNxN=NxN個            


                backtrack2
                           backtrack2は1行目が右端以外の処理             
                □□□□□□□□   1行目が右端以外 B1の値に配置    
                |    |     |          |
               □□□□  □□□□  □□□□  ・・ □□□□  2行目はkの値に配置
              □□□□  □□□□  □□□□       □□□□
          |   |     |     |      |     |         |
        □□□□  □□□□  □□□□  □□□□   □□□□  □□□□  ・・□□□□  3行目はjの値に配置
       □□□□  □□□□  □□□□  □□□□   □□□□  □□□□      □□□□   
                           スレッド数は (N-1)xNxN個


実行結果
 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.01
10:             724               92          00:00:00:00.01
11:            2680              341          00:00:00:00.02
12:           14200             1787          00:00:00:00.03
13:           73712             9233          00:00:00:00.05
14:          365596            45752          00:00:00:00.08
15:         2279184           285053          00:00:00:00.16
16:        14772512          1846955          00:00:00:00.56
17:        95815104         11977939          00:00:00:03.60
18:       666090624         83263591          00:00:00:28.16


 <>29．マルチスレッドもっと最適化    			        NQueen29() N17=
  BarckTrack1について修正。
  現行の処理ではすでに最上段と上から２段目のクイーンまでは固定化してスレッドかしている。
  今回は、上記に加えて上から３段目のクイーンまでを固定化してスレッド化（1XNxN)


          backTrack1          
  最上段の角にクイーンがある  
        1   2   3   4
      +   +   +   +   *
1                   Q    クイーンが角にある場合
      +   +   +   +   *
2       Q   Q   Q   Q    ここまでは従来まででスレッド化できていた。
      +   +   +   +   *
3       Q   Q   Q   Q    今回は上から３段目までスレッド化した
      +   +   +   +   *
4
      +   +   +   +   *


          backTrack2
  最上段の済みにクイーンがない
          1   2   3   4
        +   +   +   +   *
  1       Q   Q   Q          
        +   +   +   +   *
  2       Q   Q   Q   Q    
        +   +   +   +   *
  3       Q   Q   Q   Q    ←ここを新設した。
        +   +   +   +   *
  4
        +   +   +   +   *                    


　これにより上から３段目までのマスの全てがスレッド化したと言える。

          1   2   3   4
        +   +   +   +   *
  1       Q   Q   Q   Q     
        +   +   +   +   *
  2       Q   Q   Q   Q    
        +   +   +   +   *
  3       Q   Q   Q   Q    
        +   +   +   +   *
  4
        +   +   +   +   *                    

実行結果 07_29NQueen.c 
実行方法:

top - 06:15:18 up 36 min,  1 user,  load average: 2033.98, 1608.15, 1174.78
Tasks: 855 total,  16 running, 839 sleeping,   0 stopped,   0 zombie
%Cpu0  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu1  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu2  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu3  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu4  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu5  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu6  : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu7  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu8  : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu9  : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.3 st
%Cpu10 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu11 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu12 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu13 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu14 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu15 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu16 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu17 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu18 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu19 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu20 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu21 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu22 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu23 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu24 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu25 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.3 st
%Cpu26 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu27 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu28 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu29 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu30 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu31 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu32 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu33 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu34 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu35 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu36 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu37 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu38 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu39 : 98.4 us,  0.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu40 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu41 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu42 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.3 st
%Cpu43 : 98.7 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu44 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu45 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu46 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st
%Cpu47 : 99.1 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.9 si,  0.0 st


   29．マルチスレッドもっと最適化       NQueen29() N17=    03.41 N18=00:28.60 大暴走
		$ make nq29 && ./07_29NQueen

 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.01
10:             724               92          00:00:00:00.01
11:            2680              341          00:00:00:00.02
12:           14200             1787          00:00:00:00.04
13:           73712             9233          00:00:00:00.05
14:          365596            45752          00:00:00:00.08
15:         2279184           285053          00:00:00:00.17
16:        14772512          1846955          00:00:00:00.58
17:        95815104         11977939          00:00:00:03.41
18:       666090624         83263591          00:00:00:28.60


 <>30．マルチスレッドもっと最適化４段目 NQueen29() N17=    05.33

  現行の処理ではすでに最上段と上から3段目のクイーンまでは固定化してスレッド化している。
  今回は、上記に加えて上から4段目のクイーンまでを固定化してスレッド化（1XNxNxN)


	07_28 07_29は暴れん坊過ぎてハングアップするので修正、かつ強化。

          1   2   3   4
        +   +   +   +   *
  1       Q   Q   Q   Q     
        +   +   +   +   *
  2       Q   Q   Q   Q    
        +   +   +   +   *
  3       Q   Q   Q   Q    
        +   +   +   +   *
  4       Q   Q   Q   Q
        +   +   +   +   *                    

  補助機能として、THREAD フラグのトグルで、シングルスレッドモード、スレッドモードへの
  切り替えを可能とした。

  シングルスレッドモードで、Debugフラグを( 1=TRUE ) にすると、チェスボードのクイーンＱ
  配置を確認できる機能を実装した。


 実行結果
 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               8                4          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.01
 8:              92               12          00:00:00:00.02
 9:             352               46          00:00:00:00.03
10:             724               92          00:00:00:00.06
11:            2680              341          00:00:00:00.08
12:           14200             1787          00:00:00:00.13
13:           73712             9233          00:00:00:00.17
14:          365596            45752          00:00:00:00.25
15:         2279184           285053          00:00:00:00.36
16:        14772512          1846955          00:00:00:00.95
17:        95815104         11977939          00:00:00:04.53
18:       666090624         83263591          00:00:00:31.91
19:      4968057848        621012754          00:00:04:13.62
20:     39029188884       4878666808          00:00:31:20.65
21:    314666222712      39333324973          00:04:15:55.95
*/

 <>31. マルチスレッドもっと最適化5段目    			        

  現行の処理ではすでに最上段と上から4段目のクイーンまでは固定化してスレッド化している。
  今回は、上記に加えて上から5段目のクイーンまでを固定化してスレッド化（1XNxNxNxN)

  Ｎが小さい場合はこれまでの処理は確かに高速だ。
  がしかし、Ｎが大きくなるにつれて、インクリメントされるB1から派生する行処理時間の偏りが
  目立つ。これを是正するために、固定する段を増やしてきた。
  同時にスレッドを生成するコストは否めないものの、偏りはほぼ解消され、Ｎ８であれば、
  Ｎ２とＮ３の処理だけが残り、他のスレッドは終了していると言ったケースが無くなった。
  これにより、Ｎが大きければ大きいほど効果が現れてくる。
  反面、Ｎが小さい場合は、これまでの処理の法が高速となる。（後が続かないが）
  こういいった問題解決をB1スレッドのインクリメント処理ではなく、ランダムに順次処理する
  手法がこれまでの論文では多く見受けられるが、所詮、Ｎが１７を越えた場合、以下に平均的に
  Ｎの処理スレッドを並行稼働させるか、偏りをなくすかと言うことを解決したケースは、
  今回実装した手法以外に見受けられない。
  
          1   2   3   4   5
        +   +   +   +   +   + 
  1       Q   Q   Q   Q   Q  
        +   +   +   +   +   +
  2       Q   Q   Q   Q   Q
        +   +   +   +   +   +
  3       Q   Q   Q   Q   Q
        +   +   +   +   +   +
  4       Q   Q   Q   Q   Q
        +   +   +   +   +   +                  
  5       Q   Q   Q   Q   Q
        +   +   +   +   +   +                

  補助機能として、THREAD フラグのトグルで、シングルスレッドモード、スレッドモードへの
  切り替えを可能とした。

  シングルスレッドモードで、Debugフラグを( 1=TRUE ) にすると、チェスボードのクイーンＱ
  配置を確認できる機能を実装した。

 N:        Total       Unique                 dd:hh:mm:ss.ms
 8:              92               12          00:00:00:00.19
 9:             352               46          00:00:00:00.30
10:             724               92          00:00:00:00.58
11:            2680              341          00:00:00:00.86
12:           14200             1787          00:00:00:01.47
13:           73712             9233          00:00:00:02.04
14:          365596            45752          00:00:00:03.26
15:         2279184           285053          00:00:00:04.40
16:        14772512          1846955          00:00:00:06.87
17:        95815104         11977939          00:00:00:12.55
18:       666090624         83263591          00:00:00:46.62


   32. マルチスレッドもっと最適化  ハイブリッド版

 N18までは07_27で実装した２段階
 N19は07_28で実装した３段階
 N20は07_29で実装した４段階
 N21以降はは07_31で実装した５段階で処理するようにした。
 Nが大きくなればなるほど不均衡で偏りが出て遅くなる傾向にあった処理速度は、
 改善され、Nが大きくなればなるほど、これまでの計測値よりも高速となっている。 
 N16までは段固定処理ではなく07_26のシングル処理の方が高速だった。

 N:        Total       Unique                 dd:hh:mm:ss.ms
 2:               0                0          00:00:00:00.00
 3:               0                0          00:00:00:00.00
 4:               2                1          00:00:00:00.00
 5:              10                2          00:00:00:00.00
 6:               4                1          00:00:00:00.00
 7:              40                6          00:00:00:00.00
 8:              92               12          00:00:00:00.00
 9:             352               46          00:00:00:00.00
10:             724               92          00:00:00:00.00
11:            2680              341          00:00:00:00.00
12:           14200             1787          00:00:00:00.00
13:           73712             9233          00:00:00:00.00
14:          365596            45752          00:00:00:00.01
15:         2279184           285053          00:00:00:00.08
16:        14772512          1846955          00:00:00:00.49
17:        95815104         11977939          00:00:00:03.61
18:       666090624         83263591          00:00:00:29.67


 33. マルチスレッド 脱malloc 

 N18までは07_27で実装した２段階 k
 N19は07_28で実装した３段階     j
 N20は07_29で実装した４段階     kj4
 N21は07_31で実装した５段階で処理するようにした。 kj5
 さらに N22,N23,N24,N25とNが大きくなるにつれて、スレッドの階層も増える。
 これにより、Nが大きくなればなるほど不均衡で偏りが出て遅くなる傾向にあった処理速度の遅延は改善された。 の、malloc卒業版
常にスレッド数はＮに制限され、最大で9段階にシフトしながら解析処理を進めていく。

 N:          Total        Unique                 dd:hh:mm:ss.ms
 2:                 0                 0          00:00:00:00.00
 3:                 0                 0          00:00:00:00.00
 4:                 2                 1          00:00:00:00.00
 5:                10                 2          00:00:00:00.00
 6:                 4                 1          00:00:00:00.00
 7:                40                 6          00:00:00:00.00
 8:                92                12          00:00:00:00.00
 9:               352                46          00:00:00:00.00
10:               724                92          00:00:00:00.00
11:              2680               341          00:00:00:00.00
12:             14200              1787          00:00:00:00.00
13:             73712              9233          00:00:00:00.00
14:            365596             45752          00:00:00:00.01
15:           2279184            285053          00:00:00:00.07
16:          14772512           1846955          00:00:00:00.52
17:          95815104          11977939          00:00:00:03.86
18:         666090624          83263591          00:00:00:30.94
19:        4968057848         621012754          00:00:05:08.98
20:       39029188884        4878666808          00:00:40:31.91
21:      314666222712       39333324973          00:05:38:49.56
22:     2691008701644      336376244042          02:02:03:49.27

